diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 00000000..2dc12354
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,26 @@
+* text=auto eol=lf
+
+*.java          text diff=java
+*.gradle        text diff=groovy
+*.gradle.kts    text diff=groovy
+*.css           text diff=css
+*.df            text
+*.htm           text diff=html
+*.html          text diff=html
+*.js            text
+*.jsp           text
+*.jspf          text
+*.jspx          text
+*.properties    text
+*.tld           text
+*.tag           text
+*.tagx          text
+*.xml           text
+
+*.class         binary
+*.dll           binary
+*.ear           binary
+*.jar           binary
+*.so            binary
+*.war           binary
+*.jks           binary
diff --git a/.github/workflows/ci-dockerfile.yml b/.github/workflows/ci-dockerfile.yml
new file mode 100644
index 00000000..cdf701e3
--- /dev/null
+++ b/.github/workflows/ci-dockerfile.yml
@@ -0,0 +1,21 @@
+name: ci-dockerfile
+on:
+  push:
+    branches:
+    - master
+    paths:
+    - Dockerfile
+    pull_request:
+      types:
+      - opened
+      - synchronize
+      - reopened
+      paths:
+      - Dockerfile
+jobs:
+  lint:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v2
+    - run: docker pull hadolint/hadolint
+    - run: docker run --rm --interactive hadolint/hadolint < Dockerfile
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 4e376f5a..6f05283f 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -13,6 +13,8 @@ jobs:
     runs-on: ubuntu-latest
     steps:
     - uses: actions/checkout@v2
+      with:
+        fetch-depth: 0
     - uses: actions/cache@v1
       env:
         cache-name: m2
@@ -23,9 +25,50 @@ jobs:
     - uses: actions/setup-java@v1
       with:
         java-version: 11
-    - run: |
-        mvn --batch-mode package
+    - name: mvn package
+      if: ${{ github.event_name == 'pull_request' }}
+      run: mvn --batch-mode package
+    - name: mvn deploy
+      if: ${{ github.event_name == 'push' }}
+      run: mvn --batch-mode deploy
+      env:
+        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+    - name: mvn sonar
+      if: ${{ github.event_name == 'push' }}
+      run: |
+        mvn --batch-mode verify sonar:sonar \
+        -Dsonar.login=${SONAR_TOKEN} \
+        -Dsonar.host.url=${SONAR_URL} \
+        -Dsonar.organization=${GITHUB_REPOSITORY_OWNER} \
+        -Dsonar.projectKey=${GITHUB_REPOSITORY/\//_}
+      env:
+        SONAR_URL: https://sonarcloud.io
+        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
+        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
     - uses: actions/upload-artifact@v1
       with:
         name: target
         path: target
+  package:
+    needs: build
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v2
+    - uses: actions/download-artifact@v1
+      with:
+        name: target
+        path: target
+    - name: docker build
+      if: ${{ github.event_name == 'pull_request' }}
+      run: docker build .
+    - name: docker build and push
+      if: ${{ github.event_name == 'push' }}
+      run: |
+        sudo apt-get install --yes --no-install-recommends libxml-xpath-perl
+        ARTIFACT_ID=$(xpath -q -e "/project/artifactId/text()" pom.xml)
+        VERSION=$(xpath -q -e "/project/version/text()" pom.xml)
+        echo ${GITHUB_TOKEN} | docker login docker.pkg.github.com -u ${GITHUB_REPOSITORY_OWNER} --password-stdin
+        docker build --tag docker.pkg.github.com/${GITHUB_REPOSITORY}/${ARTIFACT_ID}:${VERSION} .
+        docker push docker.pkg.github.com/${GITHUB_REPOSITORY}/${ARTIFACT_ID}:${VERSION}
+      env:
+        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 2daf5c97..700fef4c 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -4,9 +4,9 @@
 
 All members of the project community must abide by the [Contributor Covenant, version 2.0](CODE_OF_CONDUCT.md).
 Only by respecting each other can we develop a productive, collaborative community.
-Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting [opensource@telekom.de](mailto:opensource@telekom.de) and/or a project maintainer. 
+Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting [opensource@telekom.de](mailto:opensource@telekom.de) and/or a project maintainer.
 
-We appreciate your courtesy of avoiding political questions here. Issues which are not related to the project itself will be closed by our community managers. 
+We appreciate your courtesy of avoiding political questions here. Issues which are not related to the project itself will be closed by our community managers.
 
 ## Engaging in our project
 
@@ -35,8 +35,8 @@ You are welcome to contribute code in order to fix a bug or to implement a new f
 The following rule governs code contributions:
 
 * Contributions must be licensed under the [Apache 2.0 License](LICENSE)
-* Newly created files must be opened by an instatiated version fo the file 'templates/file-header.txt'
-* At least if you add a new file to the repository, add your name into the contributor section of the file NOTICE (please respect the preset entry structure) 
+* Newly created files must be opened by an instantiated version of the file 'templates/file-header.txt'
+* At least if you add a new file to the repository, add your name into the contributor section of the file NOTICE (please respect the preset entry structure)
 
 ## Contributing Documentation
 
@@ -66,7 +66,7 @@ The following rule governs documentation contributions:
 
 ## Issues and Planning
 
-* We use GitHub issues to track bugs and enhancement requests. 
+* We use GitHub issues to track bugs and enhancement requests.
 
 * Please provide as much context as possible when you open an issue. The information you provide must be comprehensive enough to reproduce that issue for the assignee. Therefore, contributors may use but aren't restricted to the issue template provided by the project maintainers.
 
diff --git a/Dockerfile b/Dockerfile
index d6caf119..ad505f46 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,18 +1,4 @@
-FROM maven:3.6.3-jdk-11 as build
-
-ARG WORK_DIR=/build
-
-COPY . ${WORK_DIR}/
-WORKDIR ${WORK_DIR}
-
-RUN mkdir -p /root/.m2 /usr/tsi/verification-server
-RUN cd ${WORK_DIR}
-RUN mvn -B ${MAVEN_ARGS} install
-RUN cp ${WORK_DIR}/target/cwa-verification-server*.jar /usr/tsi/verification-server/verification.jar
-
 FROM gcr.io/distroless/java:11
-COPY --from=build /usr/tsi/verification-server/verification.jar .
-CMD ["verification.jar"]
+COPY target/*.jar app.jar
+CMD ["app.jar"]
 EXPOSE 8080
-LABEL Version="0.3.2-SNAPSHOT"
-LABEL Name="cwa-verification-server"
diff --git a/DockerfileCi b/DockerfileCi
deleted file mode 100644
index 464ac312..00000000
--- a/DockerfileCi
+++ /dev/null
@@ -1,6 +0,0 @@
-FROM gcr.io/distroless/java:11
-COPY target/cwa-verification-server-*.jar verification.jar
-CMD ["verification.jar"]
-EXPOSE 8080
-LABEL Version="0.3.2-SNAPSHOT"
-LABEL Name="cwa-verification-server"
diff --git a/DockerfilePaaS b/DockerfilePaaS
new file mode 100644
index 00000000..47762d3a
--- /dev/null
+++ b/DockerfilePaaS
@@ -0,0 +1,15 @@
+FROM maven:3.6.3-jdk-11 as build
+
+ARG WORK_DIR=/build
+
+COPY . ${WORK_DIR}/
+WORKDIR ${WORK_DIR}
+
+RUN mkdir -p /root/.m2 /usr/tsi
+RUN mvn -B -DskipTests=true ${MAVEN_ARGS} install
+RUN cp ${WORK_DIR}/target/*.jar /usr/tsi/app.jar
+
+FROM gcr.io/distroless/java:11
+COPY --from=build /usr/tsi/app.jar .
+CMD ["app.jar"]
+EXPOSE 8080
diff --git a/Jenkinsfile b/Jenkinsfile
index c45b6c21..62d94ef9 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -8,7 +8,6 @@
  */
 sbsBuild(
   jdk: 'jdk11',
-  dockerfile: 'DockerfileCi',
   dockerAlternateRegistries: [
     'MTR_SBS@mtr.external.otc.telekomcloud.com/sbs/cwa-verification-server'
   ]
diff --git a/NOTICE b/NOTICE
index 23a0b696..447c1f1a 100644
--- a/NOTICE
+++ b/NOTICE
@@ -15,3 +15,4 @@ Andreas Scheibal [ascheibal], T-Systems International GmbH
 Michael Schulte [mschulte-tsi], T-Systems International GmbH
 Lars Stelzner [lstelzne-tech], T-Systems International GmbH
 Andreas Mandel [amandel], T-Systems International GmbH
+Martin Scheffler [martinschefflerTSI] T-Systems International GmbH
diff --git a/README.md b/README.md
index c2dbee2b..98c4a880 100644
--- a/README.md
+++ b/README.md
@@ -20,38 +20,45 @@
 
 The goal of this project is to develop the official Corona-Warn-App for Germany based on the exposure notification API from [Apple](https://www.apple.com/covid19/contacttracing/) and [Google](https://www.google.com/covid19/exposurenotifications/). The apps (for both iOS and Android) use Bluetooth technology to exchange anonymous encrypted data with other mobile phones (on which the app is also installed) in the vicinity of an app user's phone. The data is stored locally on each user's device, preventing authorities or other parties from accessing or controlling the data. This repository contains the **verification service** for the Corona-Warn-App. This implementation is still a **work in progress**, and the code it contains is currently alpha-quality code.
 
-## Architecture Overview
-You can find an architectural overview of the component in the [solution architecture document](https://github.com/corona-warn-app/cwa-documentation/blob/master/solution_architecture.md)  
-This component of the Corona-warn-app whereas named **verification process** provides indeed two functionalities:  
+## Status
+![ci](https://github.com/corona-warn-app/cwa-verification-server/workflows/ci/badge.svg)
+[![quality gate](https://sonarcloud.io/api/project_badges/measure?project=corona-warn-app_cwa-verification-server&metric=alert_status)](https://sonarcloud.io/dashboard?id=corona-warn-app_cwa-verification-server)
+[![coverage](https://sonarcloud.io/api/project_badges/measure?project=corona-warn-app_cwa-verification-server&metric=coverage)](https://sonarcloud.io/dashboard?id=corona-warn-app_cwa-verification-server)
+[![bugs](https://sonarcloud.io/api/project_badges/measure?project=corona-warn-app_cwa-verification-server&metric=bugs)](https://sonarcloud.io/dashboard?id=corona-warn-app_cwa-verification-server)
+
+## Architecture overview
+You can find an architectural overview of the component in the [solution architecture document](https://github.com/corona-warn-app/cwa-documentation/blob/master/solution_architecture.md).  
+This component of the Corona-Warn-App whereas named **verification process** provides indeed two functionalities:  
 1. prove that a pretended positive case is indeed positive  
-2. provide the result of a Covid-19 Test  
+2. provide the result of a COVID-19 test  
 
-To achieve this, the verification service gets the result of covid-19 tests from LIS (**L**abor **I**nformation **S**ystem) which deliver test results to it. The complete process is described in [cwa-documentation/Solution Architecture](https://github.com/corona-warn-app/cwa-documentation/blob/master/solution_architecture.md) to which you may refer for detailed information about the workflow.
-
-The software stack of the verification server is based on spring boot, currently with an in-memory H2 database. As the persistence relies on the liquibase.
+To achieve this, the verification service gets the result of COVID-19 tests from LIS (**L**abor **I**nformation **S**ystem) which delivers test results to it. The complete process is described in [cwa-documentation/Solution Architecture](https://github.com/corona-warn-app/cwa-documentation/blob/master/solution_architecture.md) to which you may refer for detailed information about the workflow.
 
+The software stack of the verification server is based on [Spring Boot](https://spring.io/projects/spring-boot), currently with an in-memory H2 database. As the persistence relies on [Liquibase](https://www.liquibase.org).
 
 ## Development
+This component can be locally build in order to test the functionality of the interfaces and verify the concepts it is built upon.  
 
-This component can be locally build in order to test the functionality of the interfaces and verify the concepts it is build upon.  
 There are two ways to build:
  - [Maven](https:///maven.apache.org) build - to run this component as spring application on your local machine
  - [Docker](https://www.docker.com) build - to run it as docker container build from the provided docker build [file](https://github.com/corona-warn-app/cwa-verification-server/blob/master/Dockerfile)
- ### Prerequisites
- [Open JDK 11](https://openjdk.java.net)  
- [Maven](https://apache.maven.org)  
- *(optional)*: [Docker](https://www.docker.com)  
- ### Build
- Whether you cloned or downloaded the 'zipped' sources you will either find the sources in the chosen checkout-directory or get a zip file with the source code, which you can expand to a folder of your choice.
-
- In either case open a terminal pointing to the directory you put the sources in. The local build process is described afterwards depending on the way you choose.
+ 
+### Prerequisites
+ - [Open JDK 11](https://openjdk.java.net)  
+ - [Maven](https://apache.maven.org)  
+ - *(optional)*: [Docker](https://www.docker.com)  
+ 
+### Build
+Whether you cloned or downloaded the 'zipped' sources you will either find the sources in the chosen checkout-directory or get a zip file with the source code, which you can expand to a folder of your choice.
+
+In either case open a terminal pointing to the directory you put the sources in. The local build process is described afterwards depending on the way you choose.
+ 
 #### Maven based build
-For actively take part on the development this is the way you should choose.   
-Please check, whether following prerequisites are fulfilled
+This is the recommmended way for taking part in the development.  
+Please check, whether following prerequisites are installed on your machine:
 - [Open JDK 11](https://openjdk.java.net) or a similar JDK 11 compatible VM  
 - [Maven](https://apache.maven.org)  
-
-is installed on your machine.  
+ 
 You can then open a terminal pointing to the root directory of the verification server and do the following:
 
     mvn package
@@ -60,12 +67,9 @@ You can then open a terminal pointing to the root directory of the verification
 The verification server will start up and run locally on your machine available on port 8080.
 
 #### Docker based build  
-We recommend that you first check the prerequisites to ensure that  
-- [Docker](https://www.docker.com)  
+We recommend that you first check to ensure that [Docker](https://www.docker.com) is installed on your machine.
 
-is installed on you machine  
-
-On the commandline do the following:
+On the command line do the following:
 ```bash
 docker build -f|--file <path to dockerfile>  -t <imagename>  <path-to-verificationserver-root>
 docker run -p 127.0.0.1:8080:8080/tcp -it <imagename>
@@ -77,49 +81,40 @@ docker run -p 127.0.0.1:8080:8080/tcp -it cwa-verificationserver
 ```
 if you are in the root of the checked out repository.  
 The docker image will then run on your local machine on port 8080 assuming you configured docker for shared network mode.
-#### API Documentation  
 
-Along with the application there comes a swagger2 api documentation which you can access in your web browser, when the verification server applications runs:
+#### API documentation  
+Along with the application there comes a [swagger2](https://swagger.io) API documentation, which you can access in your web browser when the verification server applications runs:
 
     <base-url>/swagger-ui.html#/verification-controller
 
-mostly like:  
-
+Which results in the following URL on your local machine: 
 http://localhost:8080/swagger-ui.html#/verification-controller
 
-
-
 #### Remarks
 This repository contains files which support our CI/CD pipeline and will be removed without further notice  
  - DockerfileCi - used for the GitHub build chain
  - Jenkinsfile - used for Telekom internal SBS (**S**oftware**B**uild**S**ervice)
 
-
-
-## Documentation
-
+## Documentation  
 The full documentation for the Corona-Warn-App can be found in the [cwa-documentation](https://github.com/corona-warn-app/cwa-documentation) repository. The documentation repository contains technical documents, architecture information, and white papers related to this implementation.
 
-## Support and Feedback
+## Support and feedback
 The following channels are available for discussions, feedback, and support requests:
 
 | Type                     | Channel                                                |
 | ------------------------ | ------------------------------------------------------ |
-| **General Discussion**   | <a href="https://github.com/corona-warn-app/cwa-verification-server/issues/new/choose" title="General Discussion"><img src="https://img.shields.io/github/issues/corona-warn-app/cwa-verification-server/question.svg?style=flat-square"></a> </a>   |
-| **Concept Feedback**    | <a href="https://github.com/corona-warn-app/cwa-verification-server/issues/new/choose" title="Open Concept Feedback"><img src="https://img.shields.io/github/issues/corona-warn-app/cwa-verification-server/architecture.svg?style=flat-square"></a>  |
-| **Verification Server Issue**    | <a href="https://github.com/corona-warn-app/cwa-verification-server/issues" title="Open Issues"><img src="https://img.shields.io/github/issues/corona-warn-app/cwa-verification-server?style=flat"></a>  |
-| **Other Requests**    | <a href="mailto:opensource@telekom.de" title="Email CWA Team"><img src="https://img.shields.io/badge/email-CWA%20team-green?logo=mail.ru&style=flat-square&logoColor=white"></a>   |
-
-## How to Contribute
+| **General discussion**   | <a href="https://github.com/corona-warn-app/cwa-verification-server/issues/new/choose" title="General Discussion"><img src="https://img.shields.io/github/issues/corona-warn-app/cwa-verification-server/question.svg?style=flat-square"></a> </a>   |
+| **Concept feedback**    | <a href="https://github.com/corona-warn-app/cwa-verification-server/issues/new/choose" title="Open Concept Feedback"><img src="https://img.shields.io/github/issues/corona-warn-app/cwa-verification-server/architecture.svg?style=flat-square"></a>  |
+| **Verification server issues**    | <a href="https://github.com/corona-warn-app/cwa-verification-server/issues" title="Open Issues"><img src="https://img.shields.io/github/issues/corona-warn-app/cwa-verification-server?style=flat"></a>  |
+| **Other requests**    | <a href="mailto:opensource@telekom.de" title="Email CWA Team"><img src="https://img.shields.io/badge/email-CWA%20team-green?logo=mail.ru&style=flat-square&logoColor=white"></a>   |
 
+## How to contribute  
 Contribution and feedback is encouraged and always welcome. For more information about how to contribute, the project structure, as well as additional contribution information, see our [Contribution Guidelines](./CONTRIBUTING.md). By participating in this project, you agree to abide by its [Code of Conduct](./CODE_OF_CONDUCT.md) at all times.
 
-## Contributors
-
+## Contributors  
 The German government has asked SAP AG and Deutsche Telekom AG to develop the Corona-Warn-App for Germany as open source software. Deutsche Telekom is providing the network and mobile technology and will operate and run the backend for the app in a safe, scalable and stable manner. SAP is responsible for the app development, its framework and the underlying platform. Therefore, development teams of SAP and Deutsche Telekom are contributing to this project. At the same time our commitment to open source means that we are enabling -in fact encouraging- all interested parties to contribute and become part of its developer community.
 
 ## Repositories
-
 The following public repositories are currently available for the Corona-Warn-App:
 
 | Repository          | Description                                                           |
@@ -133,7 +128,6 @@ The following public repositories are currently available for the Corona-Warn-Ap
 [cwa-verification-server]: https://github.com/corona-warn-app/cwa-verification-server
 
 ## Licensing
-
 Copyright (c) 2020 Deutsche Telekom AG.
 
 Licensed under the **Apache License, Version 2.0** (the "License"); you may not use this file except in compliance with the License.
diff --git a/docs/architecture-overview.md b/docs/architecture-overview.md
index 6c1f7511..b76e64f3 100644
--- a/docs/architecture-overview.md
+++ b/docs/architecture-overview.md
@@ -2,14 +2,14 @@
 by Alexander Stiefel (alexander.stiefel@t-systems.com)
 
 ##	Introduction
-This document describes the component Verification Server for the System “Corona Warn App”. In the world of the Corona Warn App the Verification Server helps validating whether upload request from the mobile App are valid or not.
+This document describes the component Verification Server for the System “Corona Warn App”. In the world of the Corona Warn App the Verification Server helps validating whether upload requests from the mobile App are valid or not.
 This document links the overall system architecture with the software design of the Verification Server, it links user stories with implementation inside the Verification Server.
 This document is intended to be read by people who want to get insights how verification works in detail, it is our guideline for implementation.
 Please be aware that several aspects in this document are not final, certain important information is missing.
 
 #	Overview
 ##	Purpose of the Software System Component
-The primary scope of the component is to provide a proof whether users were positive tested for SARS-CoV-2. The secondary scope is to provide information about the status of a SARS-CoV-2 test and to provide the ability for privileged users (Health Authorities) to obtain a proof document on behalf of tested users.
+The primary scope of the component is to provide a proof whether users were tested positive for SARS-CoV-2. The secondary scope is to provide information about the status of a SARS-CoV-2 test and to provide the ability for privileged users (Health Authorities) to obtain a proof document on behalf of tested users.
 
 
 ##	Context
@@ -17,7 +17,7 @@ The Verification Server provides proof of a positive SARS-CoV-2 test to other co
 
 ![Overview Architecture](https://github.com/corona-warn-app/cwa-documentation/raw/master/images/solution_architecture/figure_1.svg?sanitize=true)
 
-- The Corona-Warn-App is a system which request test result status and obtains proofs. 
+- The Corona-Warn-App is a system which requests test result status and obtains proofs. 
 - The Corona-Warn-App Server is a system which needs to verify proof.
 - The Portal Server is a system which creates and obtains proof and therefore acts as source for proof.
 - The Lab Server/Laboratory Information System (LIS) is a system which acts as trusted source for proof.
@@ -26,48 +26,49 @@ Proof is represented by a Transaction Authorization Number (TAN), which is not b
 
 
 ##	Core Entities
-|Entitiy|	Definition|	
+|Entity|	Definition|	
 | ------------- |:-------------:|
-|GUID|	Identifier for a SARS-CoV-2 Test. This component will deal only with hashed instances of the GUID. For the details of the hashing see Used cryptographic algorithms. The GUID has a length of 152 Bit, it consists of a prefix of 24 bit and a main part of 128 Bit. Only the main part is generated by a cryptographical reliable process.	|
+|GUID|	Identifier for a SARS-CoV-2 Test. This component will deal only with hashed instances of the GUID. For the details of the hashing see Used cryptographic algorithms. The GUID has a length of 152 bits, it consists of a prefix of 24 bits and a main part of 128 bits. Only the main part is generated by a cryptographically reliable process.	|
 |TAN|	Is a proof that the user has a SARS-CoV-2 Test with status positive. Depending on the context the TAN has a different length. Has a default length of 128 Bit.	|
 |teleTAN|	Is a subtype of TAN with reduced length and life time. This TAN is handed over via phone and contains only uppercase letters and numbers, excluding 0,O and I,1. Length of teleTAN is 7 characters. The lifetime of a teleTAN is 1h.	|
-|SARS-CoV-2 Test|	A SARS-CoV-2 Test aggregates several probes donated by a single person to verified whether they proof an infection with the SARS-CoV-2 virus or not. A SARS-CoV-2 Test can have multiple states, “positive”, “negative”, “unknow”, “erroneous”	|
-|Registration Token|	Identifies a long term session between a mobile app and the Verification Server. The Registration Token has a length of 128 Bit.	|
+|SARS-CoV-2 Test|	A SARS-CoV-2 Test aggregates several probes donated by a single person to check whether they detect an infection with the SARS-CoV-2 virus or not. A SARS-CoV-2 Test can have multiple states, “positive”, “negative”, “unknown”, “erroneous”	|
+|Registration Token|	Identifies a long term session between a mobile app and the Verification Server. The Registration Token has a length of 128 bits.	|
 
 
 # Software Design
 
 ##	Privacy Constraints
-The Verification Server handles pseudonym data this data needs a high level of protection. The data is protected by several measures. 
+The Verification Server handles pseudonym data, this data needs a high level of protection. The data is protected by several measures. 
 
 ### Measures
 |ID|	Measure	|Comment|
 | ------------- |:-------------:| -----:|
 |M1|	Not persisting IP addresses anywhere in the Verification Server 	|
 |M2|	Early deletion of data 	|For all entities a deletion strategy is defined|
-|M3|	Make sure that application logfiles does not contain any data that is personal relatable, no hashed GUID, no GUID, no test results, no Registration Tokens	|
+|M3|	Make sure that application logfiles do not contain any data that is personal relatable, no hashed GUID, no GUID, no test results, no Registration Tokens	|
 |M4|	Persist only hashed values for personal relatable data	|
 
 
 ##	Measures to increase data privacy
 ###	Separate Operation of Verification Server and Corona-Warn-App Server
-The Verification Server and the Corona-Warn-App Server are operated by different people and run in different cloud subscriptions.
+The Verification Server and the Corona-Warn-App Server are operated by different people and run in different namespaces in one cloud tenant. The namespaces organize access rights of people for resources.
+
 ###	Logging
 Primary key or pseudonymous data must not be part of a logging statement, the only exception is detected abuse cases.
 Logfiles are kept for 30 days.
 ##	Important Assumptions
--	Diagnostic Key upload and TAN verification is executed only a defined number of times per user and test
+-	Diagnosis Keys upload and TAN verification is executed only a defined number of times per user and test
 -	The whole process of verification and upload is pseudonym not anonym
--	Only one single mobile device can access the test result via GUID and only this single one device is able to upload diagnostic keys
+-	Only one single mobile device can access the test result via GUID and only this single one device is able to upload Diagnosis Keys
 
 
 ##	Actors
 - **User/Patient**: Person, who is tested for SARS-CoV-2, is equipped with a smartphone, Corona Warn App installed 
 - **Test Center**: Facility where the user can donate a probe to be tested for SARS-CoV-2, such as hospitals or practicing doctors 
 - **Lab**: Facility which tests the probe of the user and produces a trusted test result on SARS-CoV-2. 
-- **Verification Server**: Software service which proves a user taking part in the Corona Warn App and who is willing to file his Diagnosis keys to be really tested positive by an established authority 
+- **Verification Server**: Software service which proves that a user, who is taking part in the Corona Warn App and who is willing to file his Diagnosis Keys, has been really tested positive by an established authority 
 - **Lab Server**: Software service, that imports the test results provided by the Labs and stores them for further use. 
-- **Corona Warn App Backend**: Software service, which collects the diagnosis keys of users, proves them to be valid, i.e. they are really from an infected person and transmits them to other users who have been exposed to the User during last two weeks.
+- **Corona Warn App Backend**: Software service, which collects the Diagnosis Keys of users, proves them to be valid, i.e. they are really from an infected person and transmits them to other users who have been exposed to the user during last two weeks.
 - **Hotline User**: user with the role “c19hotline”
 - **Health Authority User**: user with the role “c19healthauthority”
 
@@ -91,23 +92,23 @@ Steps:
 7.	The Lab Server is returning the Test result, if no test is available a result with state “pending” is returned
 8.	The result is returned to the mobile App
 9.	The mobile app will request a TAN if a positive test result becomes available
-- defined in User Story E07.04 Upload my Diagnostic Keys
+- defined in User Story E07.04 Upload my Diagnosis Keys
 - implemented in Use Case Create TAN
 10.	A TAN is generated by the Verification Server and the TAN is stored hashed at the Verification Server
 11.	The TAN is delivered to the mobile App
-12.	The App obtains the diagnostic keys and sends the together with the TAN string to the Corona Warn App Backend
-- defined in User Story E07.04 Upload my Diagnostic Keys
+12.	The App obtains the Diagnosis Keys and sends them together with the TAN string to the Corona Warn App Backend
+- defined in User Story E07.04 Upload my Diagnosis Keys
 13.	The Corona Warn App Backend verifies the upload request, by verifying the TAN at the Verification Server, to avoid false positive warnings and duplicate warnings.
 defined in User Story E06.01 – Avoid false positive reports
 14.	The Verification Server verifies the TAN and returns the result of the verification
 - implemented in Use Case Verify TAN
 15.	The result is returned to the Corona-Warn-App Backend
-16.	The Corona-Warn-App Backend processes the diagnostic keys.
+16.	The Corona-Warn-App Backend processes the Diagnosis Keys.
 
-Subsequent Diagnostic Key upload will repeat the steps 9. until 16..
+Subsequent Diagnosis Keys upload will repeat the steps 9. until 16.
 
-###	User Journey TAN Verification based Health Authority is-sued teleTAN
-This flow is for users which can not participate in the flow based on integrated Laboratories which relies on printed GUIDs.
+###	User Journey TAN Verification based on Health Authority issued teleTAN
+This flow is for users who can not participate in the flow based on integrated Laboratories which relies on printed GUIDs.
 
 ![User Journey TAN Verification based on integrated Laboratories](https://github.com/corona-warn-app/cwa-documentation/raw/master/images/solution_architecture/figure_4.svg?sanitize=true )
  
@@ -117,7 +118,7 @@ This flow is for users which can not participate in the flow based on integrated
 Steps
 1.	Request the creation of a teleTAN via Web Interface
 - defined in User Story E06.04 – Use Call Center for Verification
-- implemented in see Use Cases Portal Server
+- implemented in Use Cases Portal Server
 2.	The Portal Server requests a teleTAN
 
 3.	The Verification Server generates a teleTAN
@@ -130,11 +131,12 @@ implemented in Use Case Create teleTAN
 9.	The RegistrationToken is generated by the Verification Server
 - implemented in Use Case Create RegistrationKey based on teleTAN
 10.	The Registration Token is returned to the mobile app
-Steps 11. until 17. are the same as in the other TAN user journey.
-Subsequent Diagnostic Key upload will repeat the steps 11. until 17..
+
+Steps 11. until 17. are the same as steps 9. until 16. in the other TAN user journey.
+Subsequent Diagnosis Keys upload will repeat the steps 11. until 17.
 
 ##	Supported User Stories 
-The implementation of user stories around verification involved several components, this chapter documents the mapping between Verification User Stories and Verification Server Use Cases. The user stories are detailed in [Scoping].
+The implementation of user stories around verification involves several components, this chapter documents the mapping between Verification User Stories and Verification Server Use Cases. The user stories are detailed in [Scoping].
 ###	User Story E05.01 – Avoid false positive reports
 Implemented by
 * Use Case Verify TAN
@@ -144,7 +146,7 @@ Not relevant for Verification Server.
 Implemented by
 * Use Case Get Test Result
 
-###	User Story E06.03 – Submit Diagnostic keys after notification
+###	User Story E06.03 – Submit Diagnosis Keys after notification
 
 In Verification Sever implemented by
 * Use Case Create TAN
@@ -166,7 +168,7 @@ In Verification Sever implemented by
 ###	Use Case Get Test Result 
 API Endpoint:
 -	Method: POST /testresult
--	Body: { “registrationToken”: “<<registrationToken >>” }
+-	Body: { “registrationToken”: “<< registrationToken >>” }
 -	Authentication: none
 
 Steps:
@@ -177,19 +179,21 @@ Steps:
 
 ###	Use Case Create Registration Token
 It is important to note, that only one Registration Token will be generated for a specific GUID or teleTAN. The use case generates Registration Tokens from hashed GUIDs xor teleTANs. This is a measure to increase data privacy.
+
 API Endpoint:
 -	Method: POST /registrationToken
-Body: Body: { 
-"key": "<<key>>",
+Body: { 
+"key": "<< key >>",
 "keyType": “teleTAN||hashedGUID” 
 }
 -	Authentication: none
+
 Steps
 1.	Verify whether a registration token with the provided GUID or teleTAN already exists, if yes return error
 1.  If a teleTAN is used for creation, verify teleTAN.
 	1. If verification fails, return HTTP 400
 2.	Create Registration Token
-3.	Store entity AppSession, with hashed Registration Token. If available store  hashed GUID, if available store hashed teleTAN. Mark AppSession.sourceOfTrust
+3.	Store entity AppSession, with hashed Registration Token. If available store hashed GUID, if available store hashed teleTAN. Mark AppSession.sourceOfTrust
 4.	Return Registration Token.sourceOfTrust depending on which source (hashed GUID or teleTAN) was provided
 5.	If teleTAN was provided mark teleTAN as redeemed
 
@@ -198,12 +202,12 @@ The use case creates a TAN. Only a specific number of TANs can be generated for
 
 API Endpoint:
 -	Method: POST /tan
--	Body: { “registrationToken”: “<<registrationToken >>” }
+-	Body: { “registrationToken”: “<< registrationToken >>” }
 -	Authentication: none
 
 1.	Verify registrationToken, if registrationToken is invalid, exit with error HTTP 400
 2.	Verifiy whether the entity AppSession exists for the Registration token
-	1.	If yes, verify if TANcounter > 2
+	1.	If yes, check if TANcounter >= 2
 		1.	If yes, return error HTTP 400
 	1.	If no, return error HTTP 400
 3.	If AppSession.sourceOfTrust == “hashedGUID”
@@ -230,7 +234,7 @@ API Endpoint:
 ###	Use Case Verify TAN
 API Endpoint:
 -	Method: POST /tan/verify
--	Body: { “tan”: “<<tan>>” }
+-	Body: { “tan”: “<< tan >>” }
 -	Authentication: Client Certificate, IP range
 
 1.	Verify parameter TAN for syntax constraints
@@ -252,7 +256,7 @@ Steps:
 API Endpoint:
 -	Method: POST /tan
 Body: { 
-"key": "<<key>>",
+"key": "<< key >>",
 "keyType": “teleTAN||Token” 
 }
 -	Authentication: none
@@ -280,9 +284,9 @@ The entity TAN represents the authorization (sometimes referred as “proof”)
 | ------------- |:-------------:| -----:| -----:|
 |(PK) TANHash|	Y|	String[64]|	Hashed unique value of a TAN.|
 |validFrom|	Y|	Date|	Timestamp when the TAN is starting to be valid|
-|validUntil|	Y|	Date|	
+|validUntil|	Y|	Date|	Timestamp when the TAN expires|
 |sourceOfTrust|	Y|	String [“connectedLab”, "teleTAN"]|	Defines the type of the TAN|
-|Type	|Y	|String [“TAN”, “teleTAN”]|	Indicates whether this tan is tele-TAN or normal TAN |
+|Type	|Y	|String [“TAN”, “teleTAN”]|	Indicates whether this tan is teleTAN or normal TAN |
 |createdOn|	Y|	Date|	Date of creation|
 
 ###	Data Deletion
@@ -293,11 +297,11 @@ The entity AppSession is a hashed GUID which was used in processing to generate
 |Name|	Not null|	Type|	Definition|
 | ------------- |:-------------:| -----:| -----:|
 |GUIDHash|	Y|	String[64]|	The hashed GUID.|
-|teleTANHash|	Y|	String[64]|	The hashed GUID.|
-|RegistrationTokenHash|	Y|	String[64]	Hash of the Registration Token.|
-|TANcounter|	Y|Int	Contains the number of TANs generated in the session|
+|teleTANHash|	Y|	String[64]|	The hashed teleTAN.|
+|RegistrationTokenHash|	Y|	String[64]|	Hash of the Registration Token.|
+|TANcounter|	Y|Int|	Contains the number of TANs generated in the session|
 |sourceOfTrust|	Y|	String [“hashedGUID”, “teleTAN”]|Defines the type of the Session|
-|createdON|	Y|	Date	|
+|createdON|	Y|	Date	||
 
 ###	Data Deletion
 All data is deleted after 14 days.
@@ -308,7 +312,7 @@ All data is deleted after 14 days.
 |Role|	Authentication	|Comment|
 | ------------- |:-------------:| -----:|
 |Anonymous |	None|	 the app uses no authentication for communication with Verification Server|
-|Tracing Server|	TLS Client Certificate, 2nd factor IP Range	|
+|Corona Warn App Server|	TLS Client Certificate, 2nd factor IP Range	|
 |Health Authority User|	Signed JWT, verification of signature	|
 |Hotline User|	Signed JWT, verification of signature	|
 
@@ -316,22 +320,22 @@ All data is deleted after 14 days.
 ###	Authorization of users
 |Role|	Authorization|	Comment|
 | ------------- |:-------------:| -----:|
-|Anonymous| 	None|	the app uses no authentication for communication with Verification Server
-|Corona Warn App Backend User|	Implicit authorization, a user which is authenticated as Corona Warn App Backend User is authorized as Corona Warn App Backend User	|
-|Health Authority User|	Signed JWT, verification of signatureSignature contains role “c19healthauthority”	|
-|Hotline User|	Signed JWT, verification of signature “c19hotline”	|
+|Anonymous| 	None|	the app uses no authorization for communication with Verification Server |
+|Corona Warn App Backend User|	Implicit authorization | a user which is authenticated as Corona Warn App Backend User is authorized as Corona Warn App Backend User	|
+|Health Authority User|	Signed JWT, verification of signature | Signature contains role “c19healthauthority”	|
+|Hotline User|	Signed JWT | verification of signature “c19hotline”	|
 
 ## Threat Model
 **_This chapter is still in work._**
 ###	Threats
-Based STRIDE thread modelling the threats below are anticipated:
+Based on STRIDE threat modelling, the threats below are anticipated:
 |ID|	Category|	Name|	Definition|
 | ------------- |:-------------:| -----:| -----:|
-|T1|	|Brute Force	Brute Force teleTAN| 	Try to guess a teleTAN via brute force attack.
-|T2|		DDoS Attack|	The API is attacked by a high number of requests, leading to an outage of the service
-|T3|		Code injection|	The payload and/header contain code which is executed
+|T1|	Brute Force	| Brute Force teleTAN| 	Try to guess a teleTAN via brute force attack.|
+|T2|		DDoS Attack|	The API is attacked by a high number of requests, leading to an outage of the service|
+|T3|		Code injection|	The payload and/or header contain code which is executed|
 |T4|			
-|T5|		Brute force attack|	By a brute force attack a client want to guess a valid GUID to create a valid TAN
+|T5|		Brute force attack|	By a brute force attack a client wants to guess a valid GUID to create a valid TAN|
 |T6|		Steal secrets from logs	|
 			
 Categories follow STRIDE:
@@ -344,17 +348,17 @@ Categories follow STRIDE:
 
 ###	Measures
 
-|ID|	Thread|	Name|	Definition|
+|ID|	Threat|	Name|	Definition|
 | ------------- |:-------------:| -----:| -----:|
-|MT1||OTC DDoD Protection	Infrastructure Level|
-|MT2||Strong input parameter verifica-tion, with 100% code coverage and very high amount of testing	|
-|MT3||Enforcing TLS 1.2 and above	|
-|MT6|T2|	Use Open Telekom Cloud Anti-DDoS	|
-|MT7|T3|	Strict validation of http headers, body content	|
-|MT9|T5|	Use Throttling @ Code Level in API implementation to reduce the number of 	|
-|MT10|T5|	Detect unusual load scenario and trigger warning for operation	|
-|MT11|T6|	Use only POST requests to avoid logging of secrets at infra-structure components|
-|MT12||	Strict input validation, all REST input parameter are validated in a strict manner|
+|MT1|||OTC DDoD Protection	Infrastructure Level|
+|MT2|||Strong input parameter verification, with 100% code coverage and very high amount of testing	|
+|MT3|||Enforcing TLS 1.2 and above	|
+|MT6|T2||	Use Open Telekom Cloud Anti-DDoS	|
+|MT7|T3||	Strict validation of http headers, body content	|
+|MT9|T5||	Use Throttling @ Code Level in API implementation to reduce the possible frequency of guessing attempts	|
+|MT10|T5||	Detect unusual load scenario and trigger warning for operation	|
+|MT11|T6||	Use only POST requests to avoid logging of secrets at infrastructure components|
+|MT12|||	Strict input validation, all REST input parameter are validated in a strict manner|
 			
 			
 
@@ -367,14 +371,14 @@ Categories follow STRIDE:
 - Creating of teleTAN: tbd.
 
 ##	Complexity of secrets
-- TAN: 128Bit
-- Registration Token: 128 Bit
-- teleTAN: 35 Bit (5Bit per character, 7 characters)
+- TAN: 128 bits
+- Registration Token: 128 bits
+- teleTAN: 35 bits (5 bits per character, 7 characters)
 
 ## Used Timeframes
 TAN
 -	Lifespan of TAN is 14 days
+
 teleTAN
 -	Lifespan of teleTAN is 1h
 
-
diff --git a/pom.xml b/pom.xml
index 31c4986f..df5f8f05 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,31 +11,79 @@
   <name>cwa-verification-server</name>
   <description>CWA verification server project.</description>
 
-  <parent>
-    <groupId>org.springframework.boot</groupId>
-    <artifactId>spring-boot-starter-parent</artifactId>
-    <version>2.3.0.RELEASE</version>
-    <relativePath/>
-  </parent>
+  <url>https://www.coronawarn.app/</url>
+  <ciManagement>
+    <url>https://github.com/corona-warn-app/cwa-verification-server/actions?query=workflow%3Aci</url>
+  </ciManagement>
+  <issueManagement>
+    <url>https://github.com/corona-warn-app/cwa-verification-server/issues</url>
+  </issueManagement>
+  <scm>
+    <url>https://github.com/corona-warn-app/cwa-verification-server</url>
+  </scm>
 
   <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+    <!-- java -->
     <java.version>11</java.version>
     <maven.compiler.source>11</maven.compiler.source>
     <maven.compiler.target>11</maven.compiler.target>
+    <!-- charset -->
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+    <!-- dependencies -->
+    <spring.boot.version>2.3.0.RELEASE</spring.boot.version>
+    <spring.cloud.version>Hoxton.SR4</spring.cloud.version>
     <lombok.version>1.18.12</lombok.version>
     <liquibase.version>3.9.0</liquibase.version>
-    <feign.version>11.0</feign.version>
-    <openfeign.version>2.2.2.RELEASE</openfeign.version>
     <springdoc.version>1.3.9</springdoc.version>
-    <jacoco.version>0.8.5</jacoco.version>
-    <sonar.java.coveragePlugin>jacoco</sonar.java.coveragePlugin>
-    <sonar.dynamicAnalysis>reuseReports</sonar.dynamicAnalysis>
-    <sonar.jacoco.reportPath>${project.basedir}/../target/jacoco.exec</sonar.jacoco.reportPath>
-    <sonar.language>java</sonar.language>
+    <!-- plugins -->
+    <plugin.checkstyle.version>3.1.1</plugin.checkstyle.version>
+    <plugin.sonar.version>3.6.1.1688</plugin.sonar.version>
+    <plugin.jacoco.version>0.8.5</plugin.jacoco.version>
+    <guava.version>29.0-jre</guava.version>
   </properties>
 
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>org.springframework.boot</groupId>
+        <artifactId>spring-boot-dependencies</artifactId>
+        <version>${spring.boot.version}</version>
+        <type>pom</type>
+        <scope>import</scope>
+      </dependency>
+      <dependency>
+        <groupId>org.springframework.cloud</groupId>
+        <artifactId>spring-cloud-dependencies</artifactId>
+        <version>${spring.cloud.version}</version>
+        <type>pom</type>
+        <scope>import</scope>
+      </dependency>
+      <dependency>
+        <groupId>org.projectlombok</groupId>
+        <artifactId>lombok</artifactId>
+        <version>${lombok.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.springdoc</groupId>
+        <artifactId>springdoc-openapi-ui</artifactId>
+        <version>${springdoc.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.liquibase</groupId>
+        <artifactId>liquibase-core</artifactId>
+        <version>${liquibase.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <distributionManagement>
+    <repository>
+      <id>github</id>
+      <url>https://maven.pkg.github.com/corona-warn-app/cwa-verification-server</url>
+    </repository>
+  </distributionManagement>
+
   <dependencies>
     <dependency>
       <groupId>org.springframework.boot</groupId>
@@ -43,8 +91,7 @@
     </dependency>
     <dependency>
       <groupId>org.springframework.boot</groupId>
-      <artifactId>spring-boot-starter-test</artifactId>
-      <scope>test</scope>
+      <artifactId>spring-boot-starter-actuator</artifactId>
     </dependency>
     <dependency>
       <groupId>org.springframework.boot</groupId>
@@ -57,18 +104,26 @@
     <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-openfeign</artifactId>
-      <version>${openfeign.version}</version>
+      <exclusions>
+        <exclusion>
+          <groupId>com.google.guava</groupId>
+          <artifactId>guava</artifactId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>${guava.version}</version>
     </dependency>
     <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
-      <version>${lombok.version}</version>
       <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>org.springdoc</groupId>
       <artifactId>springdoc-openapi-ui</artifactId>
-      <version>${springdoc.version}</version>
     </dependency>
     <dependency>
       <groupId>commons-codec</groupId>
@@ -77,7 +132,6 @@
     <dependency>
       <groupId>org.liquibase</groupId>
       <artifactId>liquibase-core</artifactId>
-      <version>${liquibase.version}</version>
     </dependency>
     <dependency>
       <groupId>com.h2database</groupId>
@@ -89,21 +143,54 @@
       <artifactId>postgresql</artifactId>
       <scope>runtime</scope>
     </dependency>
+    <dependency>
+      <groupId>org.springframework.boot</groupId>
+      <artifactId>spring-boot-starter-test</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.springframework.boot</groupId>
+          <artifactId>spring-boot-maven-plugin</artifactId>
+          <version>${spring.boot.version}</version>
+        </plugin>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-checkstyle-plugin</artifactId>
+          <version>${plugin.checkstyle.version}</version>
+        </plugin>
+        <plugin>
+          <groupId>org.sonarsource.scanner.maven</groupId>
+          <artifactId>sonar-maven-plugin</artifactId>
+          <version>${plugin.sonar.version}</version>
+        </plugin>
+        <plugin>
+          <groupId>org.jacoco</groupId>
+          <artifactId>jacoco-maven-plugin</artifactId>
+          <version>${plugin.jacoco.version}</version>
+        </plugin>
+      </plugins>
+    </pluginManagement>
     <plugins>
       <plugin>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-maven-plugin</artifactId>
-        <configuration>
-          <fork>true</fork>
-        </configuration>
+        <executions>
+          <execution>
+            <goals>
+              <goal>repackage</goal>
+              <goal>build-info</goal>
+            </goals>
+          </execution>
+        </executions>
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>3.1.1</version>
         <configuration>
           <configLocation>codestyle/checkstyle.xml</configLocation>
           <excludes>target/**/*</excludes>
@@ -127,28 +214,14 @@
       <plugin>
         <groupId>org.jacoco</groupId>
         <artifactId>jacoco-maven-plugin</artifactId>
-        <version>${jacoco.version}</version>
-        <configuration>
-          <skip>${maven.test.skip}</skip>
-          <destFile>${basedir}/target/coverage-reports/jacoco-unit.exec</destFile>
-          <dataFile>${basedir}/target/coverage-reports/jacoco-unit.exec</dataFile>
-          <output>file</output>
-          <append>true</append>
-          <excludes>
-            <exclude>*MethodAccess</exclude>
-          </excludes>
-        </configuration>
         <executions>
           <execution>
-            <id>jacoco-initialize</id>
             <goals>
               <goal>prepare-agent</goal>
             </goals>
-            <phase>test-compile</phase>
           </execution>
           <execution>
-            <id>jacoco-site</id>
-            <phase>verify</phase>
+            <id>report</id>
             <goals>
               <goal>report</goal>
             </goals>
diff --git a/src/main/java/app/coronawarn/verification/VerificationApplication.java b/src/main/java/app/coronawarn/verification/VerificationApplication.java
index 46b57c2f..a767c25c 100644
--- a/src/main/java/app/coronawarn/verification/VerificationApplication.java
+++ b/src/main/java/app/coronawarn/verification/VerificationApplication.java
@@ -21,12 +21,15 @@
 
 package app.coronawarn.verification;
 
+import app.coronawarn.verification.config.VerificationApplicationConfig;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.SpringBootApplication;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.cloud.openfeign.EnableFeignClients;
 
-@SpringBootApplication
 @EnableFeignClients
+@SpringBootApplication
+@EnableConfigurationProperties({VerificationApplicationConfig.class})
 public class VerificationApplication {
 
   public static void main(String[] args) {
diff --git a/src/main/java/app/coronawarn/verification/client/HashedGuid.java b/src/main/java/app/coronawarn/verification/client/HashedGuid.java
index bbb65e16..30040505 100644
--- a/src/main/java/app/coronawarn/verification/client/HashedGuid.java
+++ b/src/main/java/app/coronawarn/verification/client/HashedGuid.java
@@ -1,38 +1,36 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification.client;
-
-import lombok.AllArgsConstructor;
-import lombok.Data;
-import lombok.NoArgsConstructor;
-
-/**
- * This class represents the GUID.
- *
- * @author T-Systems International GmbH
- */
-@Data
-@NoArgsConstructor
-@AllArgsConstructor
-public class HashedGuid {
-  private String id;
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.client;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * This class represents the GUID.
+ */
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+public class HashedGuid {
+  private String id;
+}
diff --git a/src/main/java/app/coronawarn/verification/client/LabServerClient.java b/src/main/java/app/coronawarn/verification/client/LabServerClient.java
index 534491f2..9c0ddc6b 100644
--- a/src/main/java/app/coronawarn/verification/client/LabServerClient.java
+++ b/src/main/java/app/coronawarn/verification/client/LabServerClient.java
@@ -1,40 +1,38 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification.client;
-
-import org.springframework.cloud.openfeign.FeignClient;
-import org.springframework.http.MediaType;
-import org.springframework.web.bind.annotation.PostMapping;
-
-/**
- * This class represents the Labor Server service client.
- *
- * @author T-Systems International GmbH
- */
-@FeignClient(name = "labServerService", url = "${uri.endpoint.labserver}")
-public interface LabServerClient {
-  @PostMapping(value = "/api/v1/app/result",
-    consumes = MediaType.APPLICATION_JSON_VALUE,
-    produces = MediaType.APPLICATION_JSON_VALUE
-  )
-  TestResult result(HashedGuid guid);
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.client;
+
+import org.springframework.cloud.openfeign.FeignClient;
+import org.springframework.http.MediaType;
+import org.springframework.web.bind.annotation.PostMapping;
+
+/**
+ * This class represents the Labor Server service client.
+ */
+@FeignClient(name = "labServerService", url = "${uri.endpoint.labserver}")
+public interface LabServerClient {
+  @PostMapping(value = "/api/v1/app/result",
+    consumes = MediaType.APPLICATION_JSON_VALUE,
+    produces = MediaType.APPLICATION_JSON_VALUE
+  )
+  TestResult result(HashedGuid guid);
+}
diff --git a/src/main/java/app/coronawarn/verification/client/TestResult.java b/src/main/java/app/coronawarn/verification/client/TestResult.java
index 3d95884d..dcc25b60 100644
--- a/src/main/java/app/coronawarn/verification/client/TestResult.java
+++ b/src/main/java/app/coronawarn/verification/client/TestResult.java
@@ -27,8 +27,6 @@
 
 /**
  * This class represents the TestResult.
- *
- * @author T-Systems International GmbH
  */
 @Data
 @NoArgsConstructor
diff --git a/src/main/java/app/coronawarn/verification/config/OpenApiConfig.java b/src/main/java/app/coronawarn/verification/config/OpenApiConfig.java
index b18806e7..23583fc2 100644
--- a/src/main/java/app/coronawarn/verification/config/OpenApiConfig.java
+++ b/src/main/java/app/coronawarn/verification/config/OpenApiConfig.java
@@ -24,29 +24,31 @@
 import io.swagger.v3.oas.models.OpenAPI;
 import io.swagger.v3.oas.models.info.Info;
 import io.swagger.v3.oas.models.info.License;
+import lombok.RequiredArgsConstructor;
+import org.springframework.boot.info.BuildProperties;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
 /**
  * This class represents the open api config.
- *
- * @author T-Systems International GmbH
  */
+@RequiredArgsConstructor
 @Configuration
 public class OpenApiConfig {
 
+  private final BuildProperties buildProperties;
+
   /**
-   * Configure the open api bean.
+   * Configure the open api bean with build property values.
    *
-   * @return the open api config
+   * @return the configured open api config
    */
   @Bean
   public OpenAPI openApi() {
     return new OpenAPI()
       .info(new Info()
-        .title("cwa-verification-server")
-        .description("OpenApi documentation of cwa-verification-server")
-        .version("0.3.2-SNAPSHOT")
+        .title(buildProperties.getArtifact())
+        .version(buildProperties.getVersion())
         .license(new License()
           .name("Apache 2.0")
           .url("http://www.apache.org/licenses/LICENSE-2.0")));
diff --git a/src/main/java/app/coronawarn/verification/config/PostSizeLimitFilter.java b/src/main/java/app/coronawarn/verification/config/PostSizeLimitFilter.java
new file mode 100644
index 00000000..34b76ce3
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/config/PostSizeLimitFilter.java
@@ -0,0 +1,38 @@
+package app.coronawarn.verification.config;
+
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.http.HttpHeaders;
+import org.springframework.http.HttpMethod;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.MediaType;
+import org.springframework.stereotype.Component;
+import org.springframework.web.filter.OncePerRequestFilter;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+
+@Component
+public class PostSizeLimitFilter extends OncePerRequestFilter {
+
+  @Value("${server.max-post-size:10000}")
+  private long maxPostSize;
+
+  @Override
+  protected void doFilterInternal(HttpServletRequest request,
+                                  HttpServletResponse response, FilterChain filterChain)
+    throws ServletException, IOException {
+    if (isPOST(request) && request.getContentLengthLong() > maxPostSize) {
+      response.setStatus(HttpStatus.NOT_ACCEPTABLE.value());
+      return;
+    }
+    filterChain.doFilter(request, response);
+  }
+
+  private boolean isPOST(HttpServletRequest httpRequest) {
+    return HttpMethod.POST.matches(httpRequest.getMethod());
+  }
+
+}
diff --git a/src/main/java/app/coronawarn/verification/config/VerificationApplicationConfig.java b/src/main/java/app/coronawarn/verification/config/VerificationApplicationConfig.java
new file mode 100644
index 00000000..4ba0205c
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/config/VerificationApplicationConfig.java
@@ -0,0 +1,58 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, YOUR_NAME, YOUR_COMPANY
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.config;
+
+import lombok.Getter;
+import lombok.Setter;
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * This class is used to read in values from configuration file application.yml.
+ * It is loaded via the @EnableConfigurationProperties annotation from SpringBootApplication main class. */
+@ConfigurationProperties
+public class VerificationApplicationConfig {
+
+  public static class TeleCfg {
+    public static class TeleValidCfg {
+      @Getter @Setter private int hours;
+    }
+
+    @Getter @Setter private TeleValidCfg valid;
+  }
+
+  public static class ValidCfg {
+    @Getter @Setter int days;
+  }
+
+  public static class TanCfg {
+    @Getter @Setter private TeleCfg tele;
+    @Getter @Setter private ValidCfg valid;
+  }
+
+  public static class AppSessionCfg {
+    @Getter @Setter int tancountermax;
+  }
+  
+  @Getter @Setter private TanCfg tan;
+  @Getter @Setter private AppSessionCfg appsession;
+
+}
diff --git a/src/main/java/app/coronawarn/verification/controller/VerificationController.java b/src/main/java/app/coronawarn/verification/controller/VerificationController.java
index f5bb9452..2c1c0c5c 100644
--- a/src/main/java/app/coronawarn/verification/controller/VerificationController.java
+++ b/src/main/java/app/coronawarn/verification/controller/VerificationController.java
@@ -1,270 +1,263 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification.controller;
-
-import app.coronawarn.verification.client.HashedGuid;
-import app.coronawarn.verification.client.TestResult;
-import app.coronawarn.verification.domain.VerificationAppSession;
-import app.coronawarn.verification.domain.VerificationTan;
-import app.coronawarn.verification.model.AppSessionSourceOfTrust;
-import app.coronawarn.verification.model.LabTestResult;
-import app.coronawarn.verification.model.RegistrationToken;
-import app.coronawarn.verification.model.RegistrationTokenKeyType;
-import app.coronawarn.verification.model.RegistrationTokenRequest;
-import app.coronawarn.verification.model.Tan;
-import app.coronawarn.verification.model.TanSourceOfTrust;
-import app.coronawarn.verification.service.AppSessionService;
-import app.coronawarn.verification.service.LabServerService;
-import app.coronawarn.verification.service.TanService;
-import io.swagger.v3.oas.annotations.Operation;
-import io.swagger.v3.oas.annotations.responses.ApiResponse;
-import io.swagger.v3.oas.annotations.responses.ApiResponses;
-import java.time.LocalDateTime;
-import java.util.Optional;
-import lombok.extern.slf4j.Slf4j;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.beans.factory.annotation.Value;
-import org.springframework.http.HttpStatus;
-import org.springframework.http.MediaType;
-import org.springframework.http.ResponseEntity;
-import org.springframework.web.bind.annotation.PostMapping;
-import org.springframework.web.bind.annotation.RequestBody;
-import org.springframework.web.bind.annotation.RequestMapping;
-import org.springframework.web.bind.annotation.RestController;
-
-/**
- * This class represents the rest controller for the verification server.
- */
-@Slf4j
-@RestController
-@RequestMapping("/version/v1")
-public class VerificationController {
-
-  /**
-   * The route to the token registration endpoint.
-   */
-  public static final String REGISTRATION_TOKEN_ROUTE = "/registrationToken";
-  /**
-   * The route to the tan generation endpoint.
-   */
-  public static final String TAN_ROUTE = "/tan";
-  /**
-   * The route to the test status of the COVID-19 test endpoint.
-   */
-  public static final String TESTRESULT_ROUTE = "/testresult";
-  /**
-   * The route to the tan verification endpoint.
-   */
-  public static final String TAN_VERIFY_ROUTE = "/tan/verify";
-  /**
-   * The route to the tele tan generation endpoint.
-   */
-  public static final String TELE_TAN_ROUTE = "/tan/teletan";
-
-  @Value("${appsession.tancountermax}")
-  private Integer tanCounterMax;
-
-  @Autowired
-  private AppSessionService appSessionService;
-
-  @Autowired
-  private LabServerService labServerService;
-
-  @Autowired
-  private TanService tanService;
-
-  /**
-   * This method generates a registrationToken by a hashed guid or a teleTan.
-   *
-   * @param request {@link RegistrationTokenRequest}
-   * @return RegistrationToken - the created registration token {@link RegistrationToken}
-   */
-  @Operation(
-    summary = "Get registration Token",
-    description = "Get a registration token by providing a SHA-256 hasehd GUID or a TeleTAN"
-  )
-  @ApiResponses(value = {
-    @ApiResponse(responseCode = "201", description = "registration token generated."),
-    @ApiResponse(responseCode = "400", description = "GUID/TeleTAN already exists."),
-  })
-  @PostMapping(value = REGISTRATION_TOKEN_ROUTE,
-    consumes = MediaType.APPLICATION_JSON_VALUE,
-    produces = MediaType.APPLICATION_JSON_VALUE
-  )
-  public ResponseEntity<RegistrationToken> generateRegistrationToken(@RequestBody RegistrationTokenRequest request) {
-    String key = request.getKey();
-    RegistrationTokenKeyType keyType = request.getKeyType();
-
-    if (keyType == RegistrationTokenKeyType.TELETAN) {
-      if (tanService.verifyTeleTan(key)) {
-        ResponseEntity<RegistrationToken> response = appSessionService.generateRegistrationToken(key, keyType);
-        Optional<VerificationTan> optional = tanService.getEntityByTan(key);
-        if (optional.isPresent()) {
-          VerificationTan teleTan = optional.get();
-          teleTan.setRedeemed(true);
-          tanService.saveTan(teleTan);
-          return response;
-        } else {
-          log.warn("Teletan is not found");
-        }
-      }
-    } else {
-      return appSessionService.generateRegistrationToken(key, keyType);
-    }
-    return ResponseEntity.badRequest().build();
-  }
-
-  /**
-   * This method generates a transaction number by a Registration Token, if
-   * the state of the COVID-19 lab-test is positive.
-   *
-   * @param registrationToken generated by a hashed guid or a teleTan. {@link RegistrationToken}
-   * @return A generated TAN (with the HTTP-state 201 Created). Otherwise the
-   *     HTTP-state 400 (Bad Request) will be returned, if an error occurs.
-   */
-  @Operation(
-    summary = "Generates a Tan",
-    description = "Generates a TAN on input of Registration Token. With the TAN one can submit his Diagnosis keys"
-  )
-  @ApiResponses(value = {
-    @ApiResponse(responseCode = "201", description = "Registration Token is valid"),
-    @ApiResponse(responseCode = "400", description = "Registration Token does not exist"),
-  })
-  @PostMapping(value = TAN_ROUTE,
-    consumes = MediaType.APPLICATION_JSON_VALUE,
-    produces = MediaType.APPLICATION_JSON_VALUE
-  )
-  public ResponseEntity<Tan> generateTan(@RequestBody RegistrationToken registrationToken) {
-
-    Optional<VerificationAppSession> actual =
-      appSessionService.getAppSessionByToken(registrationToken.getRegistrationToken());
-    if (actual.isPresent()) {
-      VerificationAppSession appSession = actual.get();
-      if (appSession.getTanCounter() < tanCounterMax) {
-        String sourceOfTrust = appSession.getSourceOfTrust();
-        if (AppSessionSourceOfTrust.HASHED_GUID.getSourceName().equals(sourceOfTrust)) {
-          sourceOfTrust = TanSourceOfTrust.CONNECTED_LAB.getSourceName();
-          TestResult covidTestResult = labServerService.result(new HashedGuid(appSession.getHashedGuid()));
-          if (covidTestResult.getTestResult() != LabTestResult.POSITIVE.getTestResult()) {
-            return ResponseEntity.badRequest().build();
-          }
-        } else if (AppSessionSourceOfTrust.TELETAN.getSourceName().equals(sourceOfTrust)) {
-          sourceOfTrust = TanSourceOfTrust.TELETAN.getSourceName();
-        } else {
-          return ResponseEntity.badRequest().build();
-        }
-        String generatedTan = tanService.generateVerificationTan(sourceOfTrust);
-        appSession.incrementTanCounter();
-        appSessionService.saveAppSession(appSession);
-        return ResponseEntity.status(HttpStatus.CREATED).body(new Tan(generatedTan));
-      }
-    }
-    return ResponseEntity.badRequest().build();
-  }
-
-  /**
-   * Returns the test status of the COVID-19 test.
-   *
-   * @param registrationToken generated by a hashed guid {@link RegistrationToken}
-   * @return the test result / status of the COVID-19 test, which can be POSITIVE, NEGATIVE, INVALID, PENDING or FAILED
-   */
-  @Operation(
-    summary = "COVID-19 test result",
-    description = "Gets the result of COVID-19 Test."
-  )
-  @ApiResponses(value = {
-    @ApiResponse(responseCode = "200", description = "Testresult retrieved"),
-  })
-  @PostMapping(value = TESTRESULT_ROUTE,
-    consumes = MediaType.APPLICATION_JSON_VALUE,
-    produces = MediaType.APPLICATION_JSON_VALUE
-  )
-  public ResponseEntity<TestResult> getTestState(@RequestBody RegistrationToken registrationToken) {
-    Optional<VerificationAppSession> actual = appSessionService
-      .getAppSessionByToken(registrationToken.getRegistrationToken());
-    if (actual.isPresent()) {
-      TestResult result = labServerService.result(new HashedGuid(actual.get().getHashedGuid()));
-      return ResponseEntity.ok(result);
-    } else {
-      log.info("The registration token is invalid.");
-      return ResponseEntity.badRequest().build();
-    }
-  }
-
-  /**
-   * This provided REST method verifies the transaction number (TAN).
-   *
-   * @param tan - the transaction number, which needs to be verified {@link Tan}
-   * @return HTTP-Status 200, if the verification was successful. Otherwise return HTTP 404.
-   */
-  @Operation(
-    summary = "Verify provided Tan",
-    description = "The provided Tan is verified to be formerly issued by the verification server"
-  )
-  @ApiResponses(value = {
-    @ApiResponse(responseCode = "200", description = "Tan is valid an formerly issued by the verification server"),
-    @ApiResponse(responseCode = "404", description = "Tan could not be verified"),
-  })
-  @PostMapping(value = TAN_VERIFY_ROUTE,
-    consumes = MediaType.APPLICATION_JSON_VALUE
-  )
-  public ResponseEntity<Void> verifyTan(@RequestBody Tan tan) {
-
-    boolean verified = false;
-    //TODO TAN syntax constraints
-    boolean syntaxVerified = tanService.syntaxVerification(tan.getTan());
-
-    if (syntaxVerified) {
-      Optional<VerificationTan> optional = tanService.getEntityByTan(tan.getTan());
-      if (optional.isPresent()) {
-        VerificationTan cvtan = optional.get();
-        LocalDateTime dateTimeNow = LocalDateTime.now();
-        boolean tanTimeValid = dateTimeNow.isAfter(cvtan.getValidFrom()) && dateTimeNow.isBefore(cvtan.getValidUntil());
-        boolean tanRedeemed = cvtan.isRedeemed();
-        if (tanTimeValid && !tanRedeemed) {
-          cvtan.setRedeemed(true);
-          tanService.saveTan(cvtan);
-          verified = true;
-        }
-      }
-    }
-    return ResponseEntity.status(verified ? HttpStatus.OK : HttpStatus.NOT_FOUND).build();
-  }
-
-  /**
-   * This method creates a TeleTan.
-   *
-   * @return a created teletan
-   */
-  @Operation(
-    summary = "Request generation of a TeleTan",
-    description = "A TeleTan is a human readable TAN with 7 characters which is supposed to be issued via call line"
-  )
-  @ApiResponses(value = {
-    @ApiResponse(responseCode = "201", description = "TeleTan created"),
-  })
-  @PostMapping(TELE_TAN_ROUTE)
-  public ResponseEntity<Void> createTeleTan() {
-    // TODO implement if the clarification about communication is done
-    return ResponseEntity.status(HttpStatus.CREATED).build();
-  }
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.controller;
+
+import app.coronawarn.verification.client.HashedGuid;
+import app.coronawarn.verification.client.TestResult;
+import app.coronawarn.verification.config.VerificationApplicationConfig;
+import app.coronawarn.verification.domain.VerificationAppSession;
+import app.coronawarn.verification.domain.VerificationTan;
+import app.coronawarn.verification.model.AppSessionSourceOfTrust;
+import app.coronawarn.verification.model.LabTestResult;
+import app.coronawarn.verification.model.RegistrationToken;
+import app.coronawarn.verification.model.RegistrationTokenKeyType;
+import app.coronawarn.verification.model.RegistrationTokenRequest;
+import app.coronawarn.verification.model.Tan;
+import app.coronawarn.verification.model.TanSourceOfTrust;
+import app.coronawarn.verification.model.TeleTan;
+import app.coronawarn.verification.service.AppSessionService;
+import app.coronawarn.verification.service.LabServerService;
+import app.coronawarn.verification.service.TanService;
+import io.swagger.v3.oas.annotations.Operation;
+import io.swagger.v3.oas.annotations.responses.ApiResponse;
+import io.swagger.v3.oas.annotations.responses.ApiResponses;
+import java.time.LocalDateTime;
+import java.util.Optional;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.MediaType;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.PostMapping;
+import org.springframework.web.bind.annotation.RequestBody;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
+
+/**
+ * This class represents the rest controller for the verification server.
+ */
+@Slf4j
+@RequiredArgsConstructor
+@RestController
+@RequestMapping("/version/v1")
+public class VerificationController {
+
+  /**
+   * The route to the token registration endpoint.
+   */
+  public static final String REGISTRATION_TOKEN_ROUTE = "/registrationToken";
+  /**
+   * The route to the tan generation endpoint.
+   */
+  public static final String TAN_ROUTE = "/tan";
+  /**
+   * The route to the test status of the COVID-19 test endpoint.
+   */
+  public static final String TESTRESULT_ROUTE = "/testresult";
+  /**
+   * The route to the tan verification endpoint.
+   */
+  public static final String TAN_VERIFY_ROUTE = "/tan/verify";
+  /**
+   * The route to the tele tan generation endpoint.
+   */
+  public static final String TELE_TAN_ROUTE = "/tan/teletan";
+
+  @NonNull
+  private final AppSessionService appSessionService;
+
+  @NonNull
+  private final LabServerService labServerService;
+
+  @NonNull
+  private final TanService tanService;
+
+  @NonNull
+  private VerificationApplicationConfig verificationApplicationConfig;
+
+  /**
+   * This method generates a registrationToken by a hashed guid or a teleTan.
+   *
+   * @param request {@link RegistrationTokenRequest}
+   * @return RegistrationToken - the created registration token
+   * {@link RegistrationToken}
+   */
+  @Operation(
+    summary = "Get registration Token",
+    description = "Get a registration token by providing a SHA-256 hasehd GUID or a TeleTAN"
+  )
+  @ApiResponses(value = {
+    @ApiResponse(responseCode = "201", description = "registration token generated."),
+    @ApiResponse(responseCode = "400", description = "GUID/TeleTAN already exists."),})
+  @PostMapping(value = REGISTRATION_TOKEN_ROUTE,
+    consumes = MediaType.APPLICATION_JSON_VALUE,
+    produces = MediaType.APPLICATION_JSON_VALUE
+  )
+  public ResponseEntity<RegistrationToken> generateRegistrationToken(@RequestBody RegistrationTokenRequest request) {
+    String key = request.getKey();
+    RegistrationTokenKeyType keyType = request.getKeyType();
+
+    if (keyType == RegistrationTokenKeyType.TELETAN) {
+      if (tanService.verifyTeleTan(key)) {
+        ResponseEntity<RegistrationToken> response = appSessionService.generateRegistrationToken(key, keyType);
+        Optional<VerificationTan> optional = tanService.getEntityByTan(key);
+        if (optional.isPresent()) {
+          VerificationTan teleTan = optional.get();
+          teleTan.setRedeemed(true);
+          tanService.saveTan(teleTan);
+          return response;
+        } else {
+          log.warn("Teletan is not found");
+        }
+      }
+    } else {
+      return appSessionService.generateRegistrationToken(key, keyType);
+    }
+    return ResponseEntity.badRequest().build();
+  }
+
+  /**
+   * This method generates a transaction number by a Registration Token, if the
+   * state of the COVID-19 lab-test is positive.
+   *
+   * @param registrationToken generated by a hashed guid or a teleTan.
+   *                          {@link RegistrationToken}
+   * @return A generated transaction number {@link Tan}.
+   */
+  @Operation(
+    summary = "Generates a Tan",
+    description = "Generates a TAN on input of Registration Token. With the TAN one can submit his Diagnosis keys"
+  )
+  @ApiResponses(value = {
+    @ApiResponse(responseCode = "201", description = "Registration Token is valid"),
+    @ApiResponse(responseCode = "400", description = "Registration Token does not exist"),})
+  @PostMapping(value = TAN_ROUTE,
+    consumes = MediaType.APPLICATION_JSON_VALUE,
+    produces = MediaType.APPLICATION_JSON_VALUE
+  )
+  public ResponseEntity<Tan> generateTan(@RequestBody RegistrationToken registrationToken) {
+
+    Optional<VerificationAppSession> actual
+      = appSessionService.getAppSessionByToken(registrationToken.getToken());
+    if (actual.isPresent()) {
+      VerificationAppSession appSession = actual.get();
+      int tancountermax = verificationApplicationConfig.getAppsession().getTancountermax();
+      if (appSession.getTanCounter() < tancountermax) {
+        AppSessionSourceOfTrust appSessionSourceOfTrust = appSession.getSourceOfTrust();
+        TanSourceOfTrust tanSourceOfTrust = TanSourceOfTrust.CONNECTED_LAB;
+
+        if (AppSessionSourceOfTrust.HASHED_GUID == appSessionSourceOfTrust) {
+          TestResult covidTestResult = labServerService.result(new HashedGuid(appSession.getHashedGuid()));
+          if (covidTestResult.getTestResult() != LabTestResult.POSITIVE.getTestResult()) {
+            return ResponseEntity.badRequest().build();
+          }
+        } else if (AppSessionSourceOfTrust.TELETAN == appSessionSourceOfTrust) {
+          tanSourceOfTrust = TanSourceOfTrust.TELETAN;
+        } else {
+          return ResponseEntity.badRequest().build();
+        }
+        String generatedTan = tanService.generateVerificationTan(tanSourceOfTrust);
+        appSession.incrementTanCounter();
+        appSessionService.saveAppSession(appSession);
+        return ResponseEntity.status(HttpStatus.CREATED).body(new Tan(generatedTan));
+      }
+    }
+    return ResponseEntity.badRequest().build();
+  }
+
+  /**
+   * Returns the test status of the COVID-19 test.
+   *
+   * @param registrationToken generated by a hashed guid
+   *                          {@link RegistrationToken}
+   * @return the test result of the COVID-19 test {@link LabTestResult}
+   */
+  @Operation(
+    summary = "COVID-19 test result",
+    description = "Gets the result of COVID-19 Test."
+  )
+  @ApiResponses(value = {
+    @ApiResponse(responseCode = "200", description = "Testresult retrieved"),})
+  @PostMapping(value = TESTRESULT_ROUTE,
+    consumes = MediaType.APPLICATION_JSON_VALUE,
+    produces = MediaType.APPLICATION_JSON_VALUE
+  )
+  public ResponseEntity<TestResult> getTestState(@RequestBody RegistrationToken registrationToken) {
+    return appSessionService.getAppSessionByToken(registrationToken.getToken())
+      .map(VerificationAppSession::getHashedGuid)
+      .map(HashedGuid::new)
+      .map(labServerService::result)
+      .map(ResponseEntity::ok)
+      .orElseGet(() -> {
+        log.info("The registration token is invalid.");
+        return ResponseEntity.badRequest().build();
+      });
+  }
+
+  /**
+   * This provided REST method verifies the transaction number (TAN).
+   *
+   * @param tan - the transaction number, which needs to be verified {@link Tan}
+   * @return HTTP 200, if the verification was successful. Otherwise HTTP 404.
+   */
+  @Operation(
+    summary = "Verify provided Tan",
+    description = "The provided Tan is verified to be formerly issued by the verification server"
+  )
+  @ApiResponses(value = {
+    @ApiResponse(responseCode = "200", description = "Tan is valid an formerly issued by the verification server"),
+    @ApiResponse(responseCode = "404", description = "Tan could not be verified"),})
+  @PostMapping(value = TAN_VERIFY_ROUTE,
+    consumes = MediaType.APPLICATION_JSON_VALUE
+  )
+  public ResponseEntity<?> verifyTan(@RequestBody Tan tan) {
+    if (!tanService.syntaxVerification(tan.getValue())) {
+      return ResponseEntity.notFound().build();
+    }
+    return tanService.getEntityByTan(tan.getValue())
+      .filter(t -> t.canBeRedeemed(LocalDateTime.now()))
+      .map(t -> {
+        tanService.deleteTan(t);
+        return t;
+      })
+      .map(t -> ResponseEntity.ok().build())
+      .orElseGet(() -> ResponseEntity.notFound().build());
+  }
+
+  /**
+   * This method generates a valid Tele-TAN.
+   *
+   * @return a created teletan
+   */
+  @Operation(
+    summary = "Request generation of a TeleTan",
+    description = "A TeleTan is a human readable TAN with 7 characters which is supposed to be issued via call line"
+  )
+  @ApiResponses(value = {
+    @ApiResponse(responseCode = "201", description = "TeleTan created"),})
+  @PostMapping(TELE_TAN_ROUTE)
+  public ResponseEntity<TeleTan> createTeleTan() {
+    String teleTan = tanService.generateVerificationTeleTan();
+    return ResponseEntity.status(HttpStatus.CREATED).body(new TeleTan(teleTan));
+  }
+}
diff --git a/src/main/java/app/coronawarn/verification/domain/VerificationAppSession.java b/src/main/java/app/coronawarn/verification/domain/VerificationAppSession.java
index fe06bdfd..9c5a21ef 100644
--- a/src/main/java/app/coronawarn/verification/domain/VerificationAppSession.java
+++ b/src/main/java/app/coronawarn/verification/domain/VerificationAppSession.java
@@ -1,83 +1,87 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification.domain;
-
-import java.io.Serializable;
-import java.time.LocalDateTime;
-import javax.persistence.Column;
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.GenerationType;
-import javax.persistence.Id;
-import javax.persistence.Table;
-import javax.persistence.Version;
-import lombok.AllArgsConstructor;
-import lombok.Data;
-import lombok.NoArgsConstructor;
-
-/**
- * This class represents the AppSession-entity.
- */
-@Data
-@NoArgsConstructor
-@AllArgsConstructor
-@Entity
-@Table(name = "app_session")
-public class VerificationAppSession implements Serializable {
-
-  private static final long serialVersionUID = 1L;
-
-  @Id
-  @GeneratedValue(strategy = GenerationType.IDENTITY)
-  @Column(name = "id")
-  private Long id;
-
-  @Version
-  @Column(name = "version")
-  private long version;
-
-  @Column(name = "created_at")
-  private LocalDateTime createdAt;
-
-  @Column(name = "updated_at")
-  private LocalDateTime updatedAt;
-
-  @Column(name = "hashed_guid")
-  private String hashedGuid;
-
-  @Column(name = "registration_token_hash")
-  private String registrationTokenHash;
-
-  @Column(name = "tele_tan_hash")
-  private String teleTanHash;
-
-  @Column(name = "tan_counter")
-  private Integer tanCounter;
-
-  @Column(name = "sot")
-  private String sourceOfTrust;
-
-  public void incrementTanCounter() {
-    this.tanCounter++;
-  }
-
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.domain;
+
+import app.coronawarn.verification.model.AppSessionSourceOfTrust;
+import java.io.Serializable;
+import java.time.LocalDateTime;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.EnumType;
+import javax.persistence.Enumerated;
+import javax.persistence.GeneratedValue;
+import javax.persistence.GenerationType;
+import javax.persistence.Id;
+import javax.persistence.Table;
+import javax.persistence.Version;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * This class represents the AppSession-entity.
+ */
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@Entity
+@Table(name = "app_session")
+public class VerificationAppSession implements Serializable {
+
+  private static final long serialVersionUID = 1L;
+
+  @Id
+  @GeneratedValue(strategy = GenerationType.IDENTITY)
+  @Column(name = "id")
+  private Long id;
+
+  @Version
+  @Column(name = "version")
+  private long version;
+
+  @Column(name = "created_at")
+  private LocalDateTime createdAt;
+
+  @Column(name = "updated_at")
+  private LocalDateTime updatedAt;
+
+  @Column(name = "hashed_guid")
+  private String hashedGuid;
+
+  @Column(name = "registration_token_hash")
+  private String registrationTokenHash;
+
+  @Column(name = "tele_tan_hash")
+  private String teleTanHash;
+
+  @Column(name = "tan_counter")
+  private Integer tanCounter;
+
+  @Column(name = "sot")
+  @Enumerated(EnumType.STRING)
+  private AppSessionSourceOfTrust sourceOfTrust;
+
+  public void incrementTanCounter() {
+    this.tanCounter++;
+  }
+
+}
diff --git a/src/main/java/app/coronawarn/verification/domain/VerificationTan.java b/src/main/java/app/coronawarn/verification/domain/VerificationTan.java
index ab006182..cec0d186 100644
--- a/src/main/java/app/coronawarn/verification/domain/VerificationTan.java
+++ b/src/main/java/app/coronawarn/verification/domain/VerificationTan.java
@@ -21,10 +21,13 @@
 
 package app.coronawarn.verification.domain;
 
+import app.coronawarn.verification.model.TanSourceOfTrust;
 import java.io.Serializable;
 import java.time.LocalDateTime;
 import javax.persistence.Column;
 import javax.persistence.Entity;
+import javax.persistence.EnumType;
+import javax.persistence.Enumerated;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
@@ -69,7 +72,8 @@ public class VerificationTan implements Serializable {
   private LocalDateTime validUntil;
 
   @Column(name = "sot")
-  private String sourceOfTrust;
+  @Enumerated(EnumType.STRING)
+  private TanSourceOfTrust sourceOfTrust;
 
   @Column(name = "redeemed")
   private boolean redeemed;
@@ -77,4 +81,16 @@ public class VerificationTan implements Serializable {
   @Column(name = "type")
   private String type;
 
+  /**
+   * Check if the tan can be redeemed by date.
+   *
+   * @param reference the date to check if it is in between from and until range
+   * @return true or false if it can be redeemed
+   */
+  public boolean canBeRedeemed(LocalDateTime reference) {
+    return validFrom.isBefore(reference)
+      && validUntil.isAfter(reference)
+      && !isRedeemed();
+  }
+
 }
diff --git a/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java b/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java
index 5009139c..9b43fbb3 100644
--- a/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java
+++ b/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java
@@ -25,16 +25,6 @@
  * This class represents the possible sources of trust for an appsession entity.
  */
 public enum AppSessionSourceOfTrust {
-  HASHED_GUID("hashedGUID"),
-  TELETAN("teleTAN");
-
-  private final String sourceName;
-
-  AppSessionSourceOfTrust(String sourceName) {
-    this.sourceName = sourceName;
-  }
-
-  public String getSourceName() {
-    return this.sourceName;
-  }
+  HASHED_GUID,
+  TELETAN
 }
diff --git a/src/main/java/app/coronawarn/verification/model/RegistrationToken.java b/src/main/java/app/coronawarn/verification/model/RegistrationToken.java
index df101120..0703d4b4 100644
--- a/src/main/java/app/coronawarn/verification/model/RegistrationToken.java
+++ b/src/main/java/app/coronawarn/verification/model/RegistrationToken.java
@@ -28,8 +28,6 @@
 
 /**
  * This class represents the registration Token.
- *
- * @author T-Systems International GmbH
  */
 @Schema
 @Data
@@ -37,5 +35,5 @@
 @AllArgsConstructor
 public class RegistrationToken {
 
-  private String registrationToken;
+  private String token;
 }
diff --git a/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java b/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java
index e1362400..fcaa4d91 100644
--- a/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java
+++ b/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java
@@ -1,47 +1,47 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification.model;
-
-import io.swagger.v3.oas.annotations.media.Schema;
-import lombok.AllArgsConstructor;
-import lombok.Data;
-import lombok.NoArgsConstructor;
-
-/**
- * This class represents a registration token request.
- */
-@Schema
-@Data
-@NoArgsConstructor
-@AllArgsConstructor
-public class RegistrationTokenRequest {
-
-  /**
-   * The key which can be a teletan or a hashed guid.
-   */
-  private String key;
-
-  /**
-   * The type of key, which can be "hashedGUID" or "teleTAN".
-   */
-  private RegistrationTokenKeyType keyType;
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.model;
+
+import io.swagger.v3.oas.annotations.media.Schema;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * This class represents a registration token request.
+ */
+@Schema
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+public class RegistrationTokenRequest {
+
+  /**
+   * The key which can be a teletan or a hashed guid.
+   */
+  private String key;
+
+  /**
+   * The type of key, which can be "hashedGUID" or "teleTAN".
+   */
+  private RegistrationTokenKeyType keyType;
+}
diff --git a/src/main/java/app/coronawarn/verification/model/Tan.java b/src/main/java/app/coronawarn/verification/model/Tan.java
index 9324a9a9..56242ce5 100644
--- a/src/main/java/app/coronawarn/verification/model/Tan.java
+++ b/src/main/java/app/coronawarn/verification/model/Tan.java
@@ -28,13 +28,12 @@
 
 /**
  * This class represents the transaction number.
- *
- * @author T-Systems International GmbH
  */
 @Schema
 @Data
 @NoArgsConstructor
 @AllArgsConstructor
 public class Tan {
-  private String tan;
+
+  private String value;
 }
diff --git a/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java b/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java
index 1b17af85..6e207339 100644
--- a/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java
+++ b/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java
@@ -25,16 +25,6 @@
  * This class represents the possible sources of trust for a TAN entity.
  */
 public enum TanSourceOfTrust {
-  CONNECTED_LAB("connectedLab"),
-  TELETAN("teleTAN");
-
-  private final String sourceName;
-
-  TanSourceOfTrust(String sourceName) {
-    this.sourceName = sourceName;
-  }
-
-  public String getSourceName() {
-    return this.sourceName;
-  }
+  CONNECTED_LAB,
+  TELETAN
 }
diff --git a/src/main/java/app/coronawarn/verification/model/TeleTan.java b/src/main/java/app/coronawarn/verification/model/TeleTan.java
new file mode 100644
index 00000000..401aa0fa
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/model/TeleTan.java
@@ -0,0 +1,39 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.model;
+
+import io.swagger.v3.oas.annotations.media.Schema;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * This class represents the tele transaction number (Tele TAN).
+ */
+@Schema
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+public class TeleTan {
+
+  private String value;
+}
diff --git a/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java b/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java
index 2866fed2..bb481baa 100644
--- a/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java
+++ b/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java
@@ -23,13 +23,9 @@
 
 import app.coronawarn.verification.domain.VerificationAppSession;
 import org.springframework.data.jpa.repository.JpaRepository;
-import org.springframework.stereotype.Repository;
 
 /**
  * This class represents the AppSession repository.
- *
- * @author T-Systems International GmbH
  */
-@Repository
 public interface VerificationAppSessionRepository extends JpaRepository<VerificationAppSession, Long> {
 }
diff --git a/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java b/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java
index 2aeed322..c6d8463a 100644
--- a/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java
+++ b/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java
@@ -23,14 +23,10 @@
 
 import app.coronawarn.verification.domain.VerificationTan;
 import org.springframework.data.jpa.repository.JpaRepository;
-import org.springframework.stereotype.Repository;
 
 /**
  * This class represents the AppSession repository.
- *
- * @author T-Systems International GmbH
  */
-@Repository
 public interface VerificationTanRepository extends JpaRepository<VerificationTan, Long> {
 
   boolean existsByTanHash(String tanHash);
diff --git a/src/main/java/app/coronawarn/verification/service/AppSessionService.java b/src/main/java/app/coronawarn/verification/service/AppSessionService.java
index 3c39cab1..6876f18f 100644
--- a/src/main/java/app/coronawarn/verification/service/AppSessionService.java
+++ b/src/main/java/app/coronawarn/verification/service/AppSessionService.java
@@ -1,210 +1,185 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification.service;
-
-import app.coronawarn.verification.domain.VerificationAppSession;
-import app.coronawarn.verification.model.AppSessionSourceOfTrust;
-import app.coronawarn.verification.model.RegistrationToken;
-import app.coronawarn.verification.model.RegistrationTokenKeyType;
-import app.coronawarn.verification.repository.VerificationAppSessionRepository;
-import java.time.LocalDateTime;
-import java.util.Optional;
-import java.util.UUID;
-import lombok.extern.slf4j.Slf4j;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.data.domain.Example;
-import org.springframework.data.domain.ExampleMatcher;
-import org.springframework.http.HttpStatus;
-import org.springframework.http.ResponseEntity;
-import org.springframework.stereotype.Component;
-
-/**
- * This class represents the VerificationAppSession service.
- *
- * @author T-Systems International GmbH
- */
-@Slf4j
-@Component
-public class AppSessionService {
-
-  /**
-   * The {@link VerificationAppSessionRepository}.
-   */
-  @Autowired
-  private VerificationAppSessionRepository appSessionRepository;
-
-  /**
-   * The {@link HashingService}.
-   */
-  @Autowired
-  private HashingService hashingService;
-  /**
-   * The {@link TanService}.
-   */
-  @Autowired
-  private TanService tanService;
-
-  /**
-   * Creates an AppSession-Entity.
-   *
-   * @param registrationToken Token for registration
-   * @return appSession for registrationToken
-   */
-  public VerificationAppSession generateAppSession(String registrationToken) {
-    log.info("Create the app session entity with the created registration token.");
-    VerificationAppSession appSession = new VerificationAppSession();
-    appSession.setCreatedAt(LocalDateTime.now());
-    appSession.setUpdatedAt(LocalDateTime.now());
-    appSession.setRegistrationTokenHash(hashingService.hash(registrationToken));
-    appSession.setTanCounter(0);
-    return appSession;
-  }
-
-
-  private String generateRegistrationToken() {
-    return UUID.randomUUID().toString();
-  }
-
-  /**
-   * This method generates a registration Token by a guid or a teletan.
-   *
-   * @param key     the guid or teletan
-   * @param keyType the key type {@link RegistrationTokenKeyType}
-   * @return an {@link ResponseEntity}
-   */
-  public ResponseEntity<RegistrationToken> generateRegistrationToken(String key, RegistrationTokenKeyType keyType) {
-    String registrationToken;
-    VerificationAppSession appSession;
-
-    switch (keyType) {
-      case GUID:
-        String hashedGuid = key;
-        if (hashingService.isHashValid(key)) {
-          if (checkRegistrationTokenAlreadyExistsForGuid(hashedGuid)) {
-            log.warn("The registration token already exists for the hashed guid.");
-          } else {
-            log.info("Start generating a new registration token for the given hashed guid.");
-            registrationToken = generateRegistrationToken();
-            appSession = generateAppSession(registrationToken);
-            appSession.setHashedGuid(hashedGuid);
-            appSession.setSourceOfTrust(AppSessionSourceOfTrust.HASHED_GUID.getSourceName());
-            saveAppSession(appSession);
-            return ResponseEntity
-              .status(HttpStatus.CREATED)
-              .body(new RegistrationToken(registrationToken));
-          }
-        }
-        break;
-      case TELETAN:
-        String teleTan = key;
-        if (tanService.isTeleTanValid(teleTan)) {
-          if (checkRegistrationTokenAlreadyExistForTeleTan(teleTan)) {
-            log.warn("The registration token already exists for this TeleTAN.");
-          } else {
-            log.info("Start generating a new registration token for the given tele TAN.");
-            registrationToken = generateRegistrationToken();
-            appSession = generateAppSession(registrationToken);
-            appSession.setTeleTanHash(hashingService.hash(teleTan));
-            appSession.setSourceOfTrust(AppSessionSourceOfTrust.TELETAN.getSourceName());
-            saveAppSession(appSession);
-            return ResponseEntity
-              .status(HttpStatus.CREATED)
-              .body(new RegistrationToken(registrationToken));
-          }
-        } else {
-          log.warn("The Tele Tan supplied is not valid.");
-        }
-        break;
-      default:
-        break;
-    }
-    return ResponseEntity.badRequest().build();
-  }
-
-  /**
-   * Persists the specified entity of {@link VerificationAppSession}
-   * instances.
-   *
-   * @param appSession the verification app session entity
-   */
-  public void saveAppSession(VerificationAppSession appSession) {
-    log.info("VerificationAppSessionService start saveAppSession.");
-    appSessionRepository.save(appSession);
-  }
-
-  /**
-   * Check for existing Reg Token in the
-   * {@link VerificationAppSessionRepository}.
-   *
-   * @param registrationTokenHash the hashed registrationToken
-   * @return flag for existing registrationToken
-   */
-  public boolean checkRegistrationTokenExists(String registrationTokenHash) {
-    log.info("VerificationAppSessionService start checkRegistrationTokenExists.");
-    VerificationAppSession appSession = new VerificationAppSession();
-    appSession.setRegistrationTokenHash(registrationTokenHash);
-    return appSessionRepository.exists(Example.of(appSession, ExampleMatcher.matchingAll()));
-  }
-
-  /**
-   * Get existing VerificationAppSession for Reg Token from
-   * {@link VerificationAppSessionRepository}.
-   *
-   * @param registrationToken the registrationToken
-   * @return Optional VerificationAppSession
-   */
-  public Optional<VerificationAppSession> getAppSessionByToken(String registrationToken) {
-    log.info("VerificationAppSessionService start getAppSessionByToken.");
-    VerificationAppSession appSession = new VerificationAppSession();
-    appSession.setRegistrationTokenHash(hashingService.hash(registrationToken));
-    return appSessionRepository.findOne(Example.of(appSession, ExampleMatcher.matchingAll()));
-  }
-
-  /**
-   * Check for existing hashed GUID Token in the
-   * {@link VerificationAppSessionRepository}.
-   *
-   * @param hashedGuid the hashed guid
-   * @return flag for existing guid
-   */
-  public boolean checkRegistrationTokenAlreadyExistsForGuid(String hashedGuid) {
-    log.info("VerificationAppSessionService start checkRegistrationTokenExists.");
-    VerificationAppSession appSession = new VerificationAppSession();
-    appSession.setHashedGuid(hashedGuid);
-    return appSessionRepository.exists(Example.of(appSession, ExampleMatcher.matchingAll()));
-  }
-
-  /**
-   * Check for existing hashed TeleTAN in the
-   * {@link VerificationAppSessionRepository}.
-   *
-   * @param teleTan the teleTAN
-   * @return flag for existing teleTAN
-   */
-  public boolean checkRegistrationTokenAlreadyExistForTeleTan(String teleTan) {
-    log.info("VerificationAppSessionService start checkTeleTanAlreadyExistForTeleTan.");
-    VerificationAppSession appSession = new VerificationAppSession();
-    appSession.setRegistrationTokenHash(hashingService.hash(teleTan));
-    return appSessionRepository.exists(Example.of(appSession, ExampleMatcher.matchingAll()));
-  }
-
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.service;
+
+import app.coronawarn.verification.domain.VerificationAppSession;
+import app.coronawarn.verification.model.AppSessionSourceOfTrust;
+import app.coronawarn.verification.model.RegistrationToken;
+import app.coronawarn.verification.model.RegistrationTokenKeyType;
+import app.coronawarn.verification.repository.VerificationAppSessionRepository;
+import java.time.LocalDateTime;
+import java.util.Optional;
+import java.util.UUID;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.data.domain.Example;
+import org.springframework.data.domain.ExampleMatcher;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class represents the VerificationAppSession service.
+ */
+@Slf4j
+@RequiredArgsConstructor
+@Component
+public class AppSessionService {
+
+  /**
+   * The {@link VerificationAppSessionRepository}.
+   */
+  @NonNull
+  private final VerificationAppSessionRepository appSessionRepository;
+
+  /**
+   * The {@link HashingService}.
+   */
+  @NonNull
+  private final HashingService hashingService;
+
+  /**
+   * Creates an AppSession-Entity.
+   *
+   * @param registrationToken Token for registration
+   * @return appSession for registrationToken
+   */
+  public VerificationAppSession generateAppSession(String registrationToken) {
+    log.info("Create the app session entity with the created registration token.");
+    VerificationAppSession appSession = new VerificationAppSession();
+    appSession.setCreatedAt(LocalDateTime.now());
+    appSession.setUpdatedAt(LocalDateTime.now());
+    appSession.setRegistrationTokenHash(hashingService.hash(registrationToken));
+    appSession.setTanCounter(0);
+    return appSession;
+  }
+
+
+  private String generateRegistrationToken() {
+    return UUID.randomUUID().toString();
+  }
+
+  /**
+   * This method generates a registration Token by a guid or a teletan.
+   *
+   * @param key     the guid or teletan
+   * @param keyType the key type {@link RegistrationTokenKeyType}
+   * @return an {@link ResponseEntity}
+   */
+  public ResponseEntity<RegistrationToken> generateRegistrationToken(String key, RegistrationTokenKeyType keyType) {
+    String registrationToken;
+    VerificationAppSession appSession;
+
+    switch (keyType) {
+      case GUID:
+        if (hashingService.isHashValid(key)) {
+          if (checkRegistrationTokenAlreadyExistsForGuid(key)) {
+            log.warn("The registration token already exists for the hashed guid.");
+          } else {
+            log.info("Start generating a new registration token for the given hashed guid.");
+            registrationToken = generateRegistrationToken();
+            appSession = generateAppSession(registrationToken);
+            appSession.setHashedGuid(key);
+            appSession.setSourceOfTrust(AppSessionSourceOfTrust.HASHED_GUID);
+            saveAppSession(appSession);
+            return ResponseEntity
+              .status(HttpStatus.CREATED)
+              .body(new RegistrationToken(registrationToken));
+          }
+        }
+        break;
+      case TELETAN:
+        if (checkRegistrationTokenAlreadyExistForTeleTan(key)) {
+          log.warn("The registration token already exists for this TeleTAN.");
+        } else {
+          log.info("Start generating a new registration token for the given tele TAN.");
+          registrationToken = generateRegistrationToken();
+          appSession = generateAppSession(registrationToken);
+          appSession.setTeleTanHash(hashingService.hash(key));
+          appSession.setSourceOfTrust(AppSessionSourceOfTrust.TELETAN);
+          saveAppSession(appSession);
+          return ResponseEntity
+            .status(HttpStatus.CREATED)
+            .body(new RegistrationToken(registrationToken));
+        }
+        break;
+      default:
+        break;
+    }
+    return ResponseEntity.badRequest().build();
+  }
+
+  /**
+   * Persists the specified entity of {@link VerificationAppSession}
+   * instances.
+   *
+   * @param appSession the verification app session entity
+   */
+  public void saveAppSession(VerificationAppSession appSession) {
+    log.info("VerificationAppSessionService start saveAppSession.");
+    appSessionRepository.save(appSession);
+  }
+
+  /**
+   * Get existing VerificationAppSession for Reg Token from
+   * {@link VerificationAppSessionRepository}.
+   *
+   * @param registrationToken the registrationToken
+   * @return Optional VerificationAppSession
+   */
+  public Optional<VerificationAppSession> getAppSessionByToken(String registrationToken) {
+    log.info("VerificationAppSessionService start getAppSessionByToken.");
+    VerificationAppSession appSession = new VerificationAppSession();
+    appSession.setRegistrationTokenHash(hashingService.hash(registrationToken));
+    return appSessionRepository.findOne(Example.of(appSession, ExampleMatcher.matchingAny()));
+  }
+
+  /**
+   * Check for existing hashed GUID Token in the
+   * {@link VerificationAppSessionRepository}.
+   *
+   * @param hashedGuid the hashed guid
+   * @return flag for existing guid
+   */
+  public boolean checkRegistrationTokenAlreadyExistsForGuid(String hashedGuid) {
+    log.info("VerificationAppSessionService start checkRegistrationTokenAlreadyExistsForGuid.");
+    VerificationAppSession appSession = new VerificationAppSession();
+    appSession.setHashedGuid(hashedGuid);
+    return appSessionRepository.exists(Example.of(appSession, ExampleMatcher.matchingAll()));
+  }
+
+  /**
+   * Check for existing hashed TeleTAN in the
+   * {@link VerificationAppSessionRepository}.
+   *
+   * @param teleTan the teleTAN
+   * @return flag for existing teleTAN
+   */
+  public boolean checkRegistrationTokenAlreadyExistForTeleTan(String teleTan) {
+    log.info("VerificationAppSessionService start checkTeleTanAlreadyExistForTeleTan.");
+    VerificationAppSession appSession = new VerificationAppSession();
+    appSession.setTeleTanHash(hashingService.hash(teleTan));
+    return appSessionRepository.exists(Example.of(appSession, ExampleMatcher.matchingAll()));
+  }
+
+}
diff --git a/src/main/java/app/coronawarn/verification/service/HashingService.java b/src/main/java/app/coronawarn/verification/service/HashingService.java
index cdd5b068..79b037d9 100644
--- a/src/main/java/app/coronawarn/verification/service/HashingService.java
+++ b/src/main/java/app/coronawarn/verification/service/HashingService.java
@@ -37,7 +37,6 @@ public class HashingService {
   private static final String GUID_HASH_PATTERN = "^[0-9A-Fa-f]{64}$";
   private static final Pattern pattern = Pattern.compile(GUID_HASH_PATTERN);
 
-
   /**
    * Returns the hash of the supplied string.
    *
diff --git a/src/main/java/app/coronawarn/verification/service/LabServerService.java b/src/main/java/app/coronawarn/verification/service/LabServerService.java
index 84117ad8..e08d66e0 100644
--- a/src/main/java/app/coronawarn/verification/service/LabServerService.java
+++ b/src/main/java/app/coronawarn/verification/service/LabServerService.java
@@ -1,44 +1,46 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification.service;
-
-import app.coronawarn.verification.client.HashedGuid;
-import app.coronawarn.verification.client.LabServerClient;
-import app.coronawarn.verification.client.TestResult;
-import lombok.extern.slf4j.Slf4j;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.stereotype.Component;
-
-/**
- * This class represents the lab server service.
- */
-@Slf4j
-@Component
-public class LabServerService {
-
-  @Autowired
-  private LabServerClient labServerClient;
-
-  public TestResult result(HashedGuid guid) {
-    return labServerClient.result(guid);
-  }
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.service;
+
+import app.coronawarn.verification.client.HashedGuid;
+import app.coronawarn.verification.client.LabServerClient;
+import app.coronawarn.verification.client.TestResult;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class represents the lab server service.
+ */
+@Slf4j
+@RequiredArgsConstructor
+@Component
+public class LabServerService {
+
+  @NonNull
+  private final LabServerClient labServerClient;
+
+  public TestResult result(HashedGuid guid) {
+    return labServerClient.result(guid);
+  }
+}
diff --git a/src/main/java/app/coronawarn/verification/service/TanService.java b/src/main/java/app/coronawarn/verification/service/TanService.java
index d3af85a8..d0393c7d 100644
--- a/src/main/java/app/coronawarn/verification/service/TanService.java
+++ b/src/main/java/app/coronawarn/verification/service/TanService.java
@@ -21,7 +21,9 @@
 
 package app.coronawarn.verification.service;
 
+import app.coronawarn.verification.config.VerificationApplicationConfig;
 import app.coronawarn.verification.domain.VerificationTan;
+import app.coronawarn.verification.model.TanSourceOfTrust;
 import app.coronawarn.verification.model.TanType;
 import app.coronawarn.verification.repository.VerificationTanRepository;
 import java.security.SecureRandom;
@@ -32,52 +34,46 @@
 import java.util.regex.Pattern;
 import java.util.stream.Collector;
 import java.util.stream.IntStream;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
-import net.bytebuddy.utility.RandomString;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.beans.factory.annotation.Value;
 import org.springframework.data.domain.Example;
 import org.springframework.data.domain.ExampleMatcher;
 import org.springframework.stereotype.Component;
 
-
 /**
  * This class represents the TanService service.
  */
 @Slf4j
+@RequiredArgsConstructor
 @Component
 public class TanService {
 
+  // TANs are UUIDs
+  private static final String UUID_PATTERN = "^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$";
+  private static final String TAN_TAN_PATTERN = UUID_PATTERN;
+  private static final Pattern TAN_PATTERN = Pattern.compile(TAN_TAN_PATTERN);
+
+  // Tele-TANs are a shorter, easier to communicate form of TAN
   private static final Integer TELE_TAN_LENGTH = 7;
   // Exclude characters which can be confusing in some fonts like 0-O or i-I-l.
   private static final String TELE_TAN_ALLOWED_CHARS = "23456789ABCDEFGHJKMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz";
   private static final String TELE_TAN_PATTERN = "^[" + TELE_TAN_ALLOWED_CHARS + "]{" + TELE_TAN_LENGTH + "}$";
   private static final Pattern PATTERN = Pattern.compile(TELE_TAN_PATTERN);
 
-  @Value("${tan.valid.days}")
-  private Integer tanValidInDays;
-  @Value("${tan.tele.valid.hours}")
-  private Integer teleTanValidInHours;
-
   /**
    * The {@link VerificationTanRepository}.
    */
-  @Autowired
-  private VerificationTanRepository tanRepository;
-
+  @NonNull
+  private final VerificationTanRepository tanRepository;
   /**
    * The {@link HashingService}.
    */
-  @Autowired
-  private HashingService hashingService;
+  @NonNull
+  private final HashingService hashingService;
 
-  /*
-   * The random number generator used by this class to create random
-   * based UUIDs. In a holder class to defer initialization until needed.
-   */
-  private static class Holder {
-    static final SecureRandom numberGenerator = new SecureRandom();
-  }
+  @NonNull
+  private VerificationApplicationConfig verificationApplicationConfig;
 
   /**
    * Saves a {@link VerificationTan} into the database.
@@ -89,15 +85,24 @@ public VerificationTan saveTan(VerificationTan tan) {
     return tanRepository.save(tan);
   }
 
+  /**
+   * Deletes a {@link VerificationTan} from the database.
+   *
+   * @param tan the tan which will be deleted
+   */
+  public void deleteTan(VerificationTan tan) {
+    tanRepository.delete(tan);
+  }
+
   /**
    * Check TAN syntax constraints.
    *
    * @param tan the TAN
    * @return TAN verification flag
    */
-  // TODO syntax constraints
   public boolean syntaxVerification(String tan) {
-    return true;
+    Matcher matcher = TAN_PATTERN.matcher(tan);
+    return matcher.find();
   }
 
   /**
@@ -121,6 +126,7 @@ public boolean verifyTeleTan(String teleTan) {
     boolean verified = false;
     if (syntaxTeleTanVerification(teleTan)) {
       Optional<VerificationTan> teleTanEntity = getEntityByTan(teleTan);
+      log.info(teleTanEntity.toString());
       if (teleTanEntity.isPresent() && !teleTanEntity.get().isRedeemed()) {
         verified = true;
       } else {
@@ -138,23 +144,13 @@ public boolean verifyTeleTan(String teleTan) {
    * @return a Valid TAN String
    */
   public String generateValidTan() {
-    return IntStream.range(0, TELE_TAN_LENGTH)
-      .mapToObj(i -> TELE_TAN_ALLOWED_CHARS.charAt(Holder.numberGenerator.nextInt(TELE_TAN_ALLOWED_CHARS.length())))
-      .collect(Collector.of(
-        StringBuilder::new,
-        StringBuilder::append,
-        StringBuilder::append,
-        StringBuilder::toString));
-  }
-
-  /**
-   * Check for existing TAN in the {@link VerificationTanRepository}.
-   *
-   * @param tan the TAN
-   * @return flag for existing TAN
-   */
-  public boolean checkTanAlreadyExist(String tan) {
-    return hashTanAndCheckAvailability(tan);
+    boolean validTan = false;
+    String newTan = "";
+    while (!validTan) {
+      newTan = generateTanFromUuid();
+      validTan = checkTanNotExist(newTan);
+    }
+    return newTan;
   }
 
   /**
@@ -164,7 +160,7 @@ public boolean checkTanAlreadyExist(String tan) {
    * @param tanType the TAN type
    * @return the persisted TAN
    */
-  private VerificationTan persistTan(String tan, TanType tanType, String sourceOfTrust) {
+  private VerificationTan persistTan(String tan, TanType tanType, TanSourceOfTrust sourceOfTrust) {
     VerificationTan newTan = generateVerificationTan(tan, tanType, sourceOfTrust);
     return tanRepository.save(newTan);
   }
@@ -175,17 +171,13 @@ private VerificationTan persistTan(String tan, TanType tanType, String sourceOfT
    * @return a new TeleTan
    */
   public String generateTeleTan() {
-    /*
-     * The generation of a TeleTan is a temporary solution and may be subject to later changes.
-     */
-    String generatedTeleTan = "";
-    boolean isTeleTanValid = false;
-
-    while (!isTeleTanValid) {
-      generatedTeleTan = RandomString.make(TELE_TAN_LENGTH);
-      isTeleTanValid = isTeleTanValid(generatedTeleTan);
-    }
-    return generatedTeleTan;
+    return IntStream.range(0, TELE_TAN_LENGTH)
+      .mapToObj(i -> TELE_TAN_ALLOWED_CHARS.charAt(Holder.NUMBER_GENERATOR.nextInt(TELE_TAN_ALLOWED_CHARS.length())))
+      .collect(Collector.of(
+        StringBuilder::new,
+        StringBuilder::append,
+        StringBuilder::append,
+        StringBuilder::toString));
   }
 
   /**
@@ -203,27 +195,46 @@ private String generateTanFromUuid() {
     return UUID.randomUUID().toString();
   }
 
-  private boolean hashTanAndCheckAvailability(String tan) {
+  /**
+   * Check for existing TAN in the {@link VerificationTanRepository}.
+   *
+   * @param tan the TAN
+   * @return flag for existing TAN
+   */
+  public boolean checkTanNotExist(String tan) {
     String tanHash = hashingService.hash(tan);
     return !tanRepository.existsByTanHash(tanHash);
   }
 
   /**
-   * This Method generates a valid TAN and persists it. Returns the generated TAN.
+   * Returns a generated valid tele TAN and persists it.
+   *
+   * @return a valid tele TAN
+   */
+  public String generateVerificationTeleTan() {
+    String teleTan = generateTeleTan();
+    persistTan(teleTan, TanType.TELETAN, TanSourceOfTrust.TELETAN);
+    return teleTan;
+  }
+
+  /**
+   * This Method generates a valid TAN and persists it. Returns the generated
+   * TAN.
    *
    * @param sourceOfTrust sets the source of Trust for the Tan
-   * @return Tan a valid tan with given source of Trust
+   * @return a valid tan with given source of Trust
    */
-  public String generateVerificationTan(String sourceOfTrust) {
+  public String generateVerificationTan(TanSourceOfTrust sourceOfTrust) {
     String tan = generateValidTan();
     persistTan(tan, TanType.TAN, sourceOfTrust);
     return tan;
   }
 
-  private VerificationTan generateVerificationTan(String tan, TanType tanType, String sourceOfTrust) {
+  protected VerificationTan generateVerificationTan(String tan, TanType tanType, TanSourceOfTrust sourceOfTrust) {
     LocalDateTime from = LocalDateTime.now();
     LocalDateTime until;
-
+    int tanValidInDays = verificationApplicationConfig.getTan().getValid().getDays();
+    int teleTanValidInHours = verificationApplicationConfig.getTan().getTele().getValid().getHours();
     if (tanType == TanType.TELETAN) {
       until = from.plusHours(teleTanValidInHours);
     } else {
@@ -243,8 +254,7 @@ private VerificationTan generateVerificationTan(String tan, TanType tanType, Str
   }
 
   /**
-   * Get existing VerificationTan by TAN from
-   * {@link VerificationTanRepository}.
+   * Get existing VerificationTan by TAN from {@link VerificationTanRepository}.
    *
    * @param tan the TAN
    * @return Optional VerificationTan
@@ -255,4 +265,13 @@ public Optional<VerificationTan> getEntityByTan(String tan) {
     tanEntity.setTanHash(hashingService.hash(tan));
     return tanRepository.findOne(Example.of(tanEntity, ExampleMatcher.matching()));
   }
+
+  /*
+   * The random number generator used by this class to create random
+   * based UUIDs. In a holder class to defer initialization until needed.
+   */
+  private static class Holder {
+
+    static final SecureRandom NUMBER_GENERATOR = new SecureRandom();
+  }
 }
diff --git a/src/main/resources/application-cloud.yml b/src/main/resources/application-cloud.yml
index 6adacee7..bf7ad533 100644
--- a/src/main/resources/application-cloud.yml
+++ b/src/main/resources/application-cloud.yml
@@ -6,3 +6,16 @@ spring:
     password: ${POSTGRESQL_PASSWORD}
   jpa:
     database-platform: org.hibernate.dialect.PostgreSQLDialect
+server:
+  port: 8080
+management:
+  server:
+    port: 8090
+  endpoints:
+    web:
+      exposure:
+        include: health
+  endpoint:
+    health:
+      show-details: ALWAYS
+      show-components: ALWAYS
diff --git a/src/main/resources/application.yml b/src/main/resources/application.yml
index 561f4ac5..82f13839 100644
--- a/src/main/resources/application.yml
+++ b/src/main/resources/application.yml
@@ -12,6 +12,8 @@ spring:
       ddl-auto: validate
   liquibase:
     change-log: classpath:db/changelog.yml
+server:
+  max-post-size: 10000
 feign:
   client:
     config:
diff --git a/src/test/java/app/coronawarn/verification/VerificationAppTests.java b/src/test/java/app/coronawarn/verification/VerificationApplicationTest.java
similarity index 62%
rename from src/test/java/app/coronawarn/verification/VerificationAppTests.java
rename to src/test/java/app/coronawarn/verification/VerificationApplicationTest.java
index d87c5b3b..d9d318dc 100644
--- a/src/test/java/app/coronawarn/verification/VerificationAppTests.java
+++ b/src/test/java/app/coronawarn/verification/VerificationApplicationTest.java
@@ -1,385 +1,554 @@
-/*
- * Corona-Warn-App / cwa-verification
- *
- * (C) 2020, T-Systems International GmbH
- *
- * Deutsche Telekom AG and all other contributors /
- * copyright owners license this file to you under the Apache
- * License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package app.coronawarn.verification;
-
-import app.coronawarn.verification.client.TestResult;
-import app.coronawarn.verification.client.HashedGuid;
-import app.coronawarn.verification.domain.VerificationAppSession;
-import app.coronawarn.verification.domain.VerificationTan;
-import app.coronawarn.verification.model.AppSessionSourceOfTrust;
-import app.coronawarn.verification.model.RegistrationToken;
-import app.coronawarn.verification.model.RegistrationTokenKeyType;
-import app.coronawarn.verification.model.RegistrationTokenRequest;
-import app.coronawarn.verification.model.Tan;
-import app.coronawarn.verification.model.TanSourceOfTrust;
-import app.coronawarn.verification.model.TanType;
-import app.coronawarn.verification.repository.VerificationAppSessionRepository;
-import app.coronawarn.verification.service.LabServerService;
-import app.coronawarn.verification.service.TanService;
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import java.time.LocalDateTime;
-import java.util.List;
-import java.util.Optional;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-import org.junit.Assert;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import org.junit.Test;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.runner.RunWith;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.doReturn;
-import org.mockito.MockitoAnnotations;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
-import org.springframework.boot.test.context.SpringBootTest;
-import org.springframework.boot.test.mock.mockito.MockBean;
-import org.springframework.http.MediaType;
-import org.springframework.test.context.ContextConfiguration;
-import org.springframework.test.context.junit4.SpringRunner;
-import org.springframework.test.web.servlet.MockMvc;
-import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
-import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
-import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
-
-/**
- * This is the test class for the verification application.
- */
-@Slf4j
-@RunWith(SpringRunner.class)
-@AutoConfigureMockMvc
-@SpringBootTest
-@ContextConfiguration(classes = VerificationApplication.class)
-public class VerificationAppTests {
-
-  public static final String TEST_GUI_HASH = "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b";
-  public static final String TEST_TELETAN = "8eFjPSV";
-  public static final String TEST_REG_TOK = "1234567890";
-  public static final String TEST_REG_TOK_HASH = "c775e7b757ede630cd0aa1113bd102661ab38829ca52a6422ab782862f268646";
-  public static final TestResult TEST_LAB_POSITIVE_RESULT = new TestResult(2);
-  public static final String TEST_TAN = "1ea6ce8a-9740-11ea-bb37-0242ac130002";
-  public static final String TEST_SOT = "connectedLab17";
-  public static final String TEST_HASHED_TAN = "16154ea91c2c59d6ef9d0e7f902a59283b1e7ff9111570d20139a4e6b1832876";
-  public static final String TEST_TAN_TYPE = "TAN";
-  static final Logger LOG = LogManager.getLogger();
-  private static final LocalDateTime TAN_VALID_UNTIL_IN_DAYS = LocalDateTime.now().plusDays(7);
-  private static final String PREFIX_API_VERSION = "/version/v1";
-
-  @Autowired
-  private MockMvc mockMvc;
-  @MockBean
-  private LabServerService labServerService;
-  @MockBean
-  private TanService tanService;
-  @Autowired
-  private VerificationAppSessionRepository appSessionrepository;
-  @Autowired
-  private ObjectMapper mapper;
-
-  @BeforeEach
-  void setUp() {
-    MockitoAnnotations.initMocks(this);
-  }
-
-  /**
-   * Test generateTAN.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callGenerateTAN() throws Exception {
-    log.info("VerificationAppTests callGenerateTAN()");
-
-    prepareAppSessionTestData();
-    doReturn(TEST_LAB_POSITIVE_RESULT).when(labServerService).result(any());
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
-      .contentType(MediaType.APPLICATION_JSON)
-      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
-      .andExpect(status().isCreated());
-
-    long count = appSessionrepository.count();
-    log.info("Got {} verification entries from db repository.", count);
-    assertEquals("Verification Failed: Amount of verfication entries is not 1 (Result=" + count + "). ", 1, count);
-
-    List<VerificationAppSession> verficationList = appSessionrepository.findAll();
-    assertNotNull(verficationList);
-    assertEquals(TEST_GUI_HASH, verficationList.get(0).getHashedGuid());
-    Assert.assertEquals(AppSessionSourceOfTrust.HASHED_GUID.getSourceName(), verficationList.get(0).getSourceOfTrust());
-    assertEquals(TEST_REG_TOK_HASH, verficationList.get(0).getRegistrationTokenHash());
-
-  }
-
-  /**
-   * Test get registration token by a guid.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callGetRegistrationTokenByGuid() throws Exception {
-    log.info("VerificationAppTests callGetRegistrationToken() ");
-
-    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_GUI_HASH, RegistrationTokenKeyType.GUID);
-    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
-      .contentType(MediaType.APPLICATION_JSON)
-      .content(getAsJsonFormat(request)))
-      .andExpect(status().isCreated())
-      .andExpect(jsonPath("$.registrationToken").exists());
-
-    long count = appSessionrepository.count();
-    log.info("Got {} verification entries from db repository.", count);
-    assertEquals("Verification Failed: Amount of verfication entries is not 1 (Result=" + count + "). ", 1, count);
-
-    List<VerificationAppSession> verificationList = appSessionrepository.findAll();
-    assertNotNull(verificationList);
-    assertEquals(TEST_GUI_HASH, verificationList.get(0).getHashedGuid());
-    assertEquals(AppSessionSourceOfTrust.HASHED_GUID.getSourceName(), verificationList.get(0).getSourceOfTrust());
-    assertNotNull(verificationList.get(0).getRegistrationTokenHash());
-  }
-
-  /**
-   * Test get registration token by a tele tan.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callGetRegistrationTokenByTeleTan() throws Exception {
-    log.info("VerificationAppTests callGetRegistrationToken() ");
-    appSessionrepository.deleteAll();
-    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_TELETAN, RegistrationTokenKeyType.TELETAN);
-    given(this.tanService.verifyTeleTan(TEST_TELETAN)).willReturn(true);
-    given(this.tanService.isTeleTanValid(TEST_TELETAN)).willReturn(true);
-    given(this.tanService.getEntityByTan(TEST_TELETAN)).willReturn(Optional.of(getTeleTanTestData()));
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
-      .contentType(MediaType.APPLICATION_JSON)
-      .content(getAsJsonFormat(request)))
-      .andExpect(status().isCreated())
-      .andExpect(jsonPath("$.registrationToken").exists());
-
-    long count = appSessionrepository.count();
-    log.info("Got {} verification entries from db repository.", count);
-    assertEquals("Verification Failed: Amount of verfication entries is not 1 (Result=" + count + "). ", 1, count);
-
-    List<VerificationAppSession> verificationList = appSessionrepository.findAll();
-    assertNotNull(verificationList);
-    assertNull(verificationList.get(0).getHashedGuid());
-    assertEquals(AppSessionSourceOfTrust.TELETAN.getSourceName(), verificationList.get(0).getSourceOfTrust());
-    assertNotNull(verificationList.get(0).getRegistrationTokenHash());
-  }
-
-  /**
-   * Test getTestState.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callGetTestState() throws Exception {
-    log.info("VerificationAppTests callGetTestState()");
-
-    prepareAppSessionTestData();
-
-    given(this.labServerService.result(new HashedGuid(TEST_GUI_HASH))).willReturn(TEST_LAB_POSITIVE_RESULT);
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/testresult").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
-      .andExpect(status().isOk())
-      .andExpect(jsonPath("$.testResult").value(TEST_LAB_POSITIVE_RESULT.getTestResult()));
-  }
-
-  /**
-   * Test getTestState with empty Entity of VerificationAppSession.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callGetTestStateByAppSessionIsEmpty() throws Exception {
-    log.info("VerificationAppTests callGetTestStateByAppSessionIsEmpty()");
-
-    //clean the repo
-    appSessionrepository.deleteAll();
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/testresult").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
-      .andExpect(status().isBadRequest());
-  }
-
-  /**
-   * Test verifyTAN.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callVerifyTAN() throws Exception {
-    log.info("VerificationAppTests callVerifyTAN()");
-
-    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
-    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(getVerificationTANTestData()));
-
-    assertFalse("Is TAN redeemed?", this.tanService.getEntityByTan(TEST_TAN).get().isRedeemed());
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
-      .andExpect(status().isOk());
-
-    assertTrue("Is TAN redeemed?", this.tanService.getEntityByTan(TEST_TAN).get().isRedeemed());
-  }
-
-  /**
-   * Test verifyTAN with empty Entity.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callVerifyTANByVerificationTANIsEmpty() throws Exception {
-    log.info("VerificationAppTests callVerifyTANByVerificationTANIsEmpty()");
-
-    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
-    // without mock tanService.getEntityByTan so this method will return empty entity
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
-      .andExpect(status().isNotFound());
-  }
-
-  /**
-   * Test verifyTAN with syntax problems.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callVerifyTANByTanSyntaxFailed() throws Exception {
-    log.info("VerificationAppTests callVerifyTANByTanSyntaxFailed()");
-
-    // without mock tanService.syntaxVerification so this method will return false
-    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(getVerificationTANTestData()));
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
-      .andExpect(status().isNotFound());
-  }
-
-  /**
-   * Test verifyTAN expired from.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callVerifyTANByExpiredTimeFrom() throws Exception {
-    log.info("VerificationAppTests callVerifyTANByTanSyntaxFailed()");
-
-    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
-    VerificationTan cvtan = getVerificationTANTestData();
-    // setValidFrom later 2 days then now
-    cvtan.setValidFrom(LocalDateTime.now().plusDays(2));
-    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(cvtan));
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
-      .andExpect(status().isNotFound());
-  }
-
-  /**
-   * Test verifyTAN expired until.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callVerifyTANByExpiredTimeUntil() throws Exception {
-    log.info("VerificationAppTests callVerifyTANByTanSyntaxFailed()");
-
-    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
-    VerificationTan cvtan = getVerificationTANTestData();
-    // setValidUntil earlier 2 days then now
-    cvtan.setValidUntil(LocalDateTime.now().minusDays(2));
-    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(cvtan));
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
-      .andExpect(status().isNotFound());
-  }
-
-  /**
-   * Test verifyTAN is redeemed.
-   *
-   * @throws Exception if the test cannot be performed.
-   */
-  @Test
-  public void callVerifyTANByIsRedeemed() throws Exception {
-    log.info("VerificationAppTests callVerifyTANByIsRedeemed()");
-
-    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
-    VerificationTan cvtan = getVerificationTANTestData();
-    // tan is redeemed
-    cvtan.setRedeemed(true);
-    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(cvtan));
-
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
-      .andExpect(status().isNotFound());
-  }
-
-  private void prepareAppSessionTestData() {
-    appSessionrepository.deleteAll();
-    appSessionrepository.save(getAppSessionTestData());
-  }
-
-  private VerificationAppSession getAppSessionTestData() {
-    VerificationAppSession cv = new VerificationAppSession();
-    cv.setHashedGuid(TEST_GUI_HASH);
-    cv.setCreatedAt(LocalDateTime.now());
-    cv.setUpdatedAt(LocalDateTime.now());
-    cv.setTanCounter(0);
-    cv.setSourceOfTrust(AppSessionSourceOfTrust.HASHED_GUID.getSourceName());
-    cv.setRegistrationTokenHash(TEST_REG_TOK_HASH);
-    return cv;
-  }
-
-  private VerificationTan getVerificationTANTestData() {
-    VerificationTan cvtan = new VerificationTan();
-    cvtan.setCreatedAt(LocalDateTime.now());
-    cvtan.setUpdatedAt(LocalDateTime.now());
-    cvtan.setRedeemed(false);
-    cvtan.setSourceOfTrust(TEST_SOT);
-    cvtan.setTanHash(TEST_HASHED_TAN);
-    cvtan.setType(TEST_TAN_TYPE);
-    cvtan.setValidFrom(LocalDateTime.now().minusDays(5));
-    cvtan.setValidUntil(TAN_VALID_UNTIL_IN_DAYS);
-    return cvtan;
-  }
-
-  private VerificationTan getTeleTanTestData() {
-    VerificationTan cvtan = new VerificationTan();
-    cvtan.setCreatedAt(LocalDateTime.now());
-    cvtan.setUpdatedAt(LocalDateTime.now());
-    cvtan.setRedeemed(false);
-    cvtan.setSourceOfTrust(TanSourceOfTrust.TELETAN.getSourceName());
-    cvtan.setTanHash(TEST_HASHED_TAN);
-    cvtan.setType(TanType.TELETAN.name());
-    cvtan.setValidFrom(LocalDateTime.now());
-    cvtan.setValidUntil(LocalDateTime.now().plusHours(1));
-    return cvtan;
-  }
-
-  private String getAsJsonFormat(Object o) throws JsonProcessingException {
-    return mapper.writeValueAsString(o);
-  }
-}
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification;
+
+import app.coronawarn.verification.client.HashedGuid;
+import app.coronawarn.verification.client.TestResult;
+import app.coronawarn.verification.domain.VerificationAppSession;
+import app.coronawarn.verification.domain.VerificationTan;
+import app.coronawarn.verification.model.AppSessionSourceOfTrust;
+import app.coronawarn.verification.model.RegistrationToken;
+import app.coronawarn.verification.model.RegistrationTokenKeyType;
+import app.coronawarn.verification.model.RegistrationTokenRequest;
+import app.coronawarn.verification.model.Tan;
+import app.coronawarn.verification.model.TanSourceOfTrust;
+import app.coronawarn.verification.model.TanType;
+import app.coronawarn.verification.repository.VerificationAppSessionRepository;
+import app.coronawarn.verification.service.LabServerService;
+import app.coronawarn.verification.service.TanService;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import java.time.LocalDateTime;
+import java.util.List;
+import java.util.Optional;
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.boot.test.mock.mockito.MockBean;
+import org.springframework.http.MediaType;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringRunner;
+import org.springframework.test.web.servlet.MockMvc;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.doReturn;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+/**
+ * This is the test class for the verification application.
+ */
+@Slf4j
+@RunWith(SpringRunner.class)
+@SpringBootTest
+@ContextConfiguration(classes = VerificationApplication.class)
+@AutoConfigureMockMvc
+public class VerificationApplicationTest {
+
+  public static final String TEST_GUI_HASH = "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b";
+  public static final String TEST_INVALID_GUI_HASH = "f0e4c2f76c58916ec2b";
+  public static final String TEST_TELE_TAN = "R3ZNUeV";
+  public static final String TEST_TELE_TAN_HASH = "eeaa54dc40aa84f587e3bc0cbbf18f7c05891558a5fe1348d52f3277794d8730";
+  public static final String TEST_REG_TOK = "1234567890";
+  public static final String TEST_REG_TOK_HASH = "c775e7b757ede630cd0aa1113bd102661ab38829ca52a6422ab782862f268646";
+  public static final TestResult TEST_LAB_POSITIVE_RESULT = new TestResult(2);
+  public static final TestResult TEST_LAB_NEGATIVE_RESULT = new TestResult(1);
+  public static final String TEST_TAN = "1ea6ce8a-9740-11ea-bb37-0242ac130002";
+  public static final TanSourceOfTrust TEST_SOT = TanSourceOfTrust.CONNECTED_LAB;
+  public static final String TEST_HASHED_TAN = "16154ea91c2c59d6ef9d0e7f902a59283b1e7ff9111570d20139a4e6b1832876";
+  public static final String TEST_TAN_TYPE = "TAN";
+  private static final LocalDateTime TAN_VALID_UNTIL_IN_DAYS = LocalDateTime.now().plusDays(7);
+  private static final String PREFIX_API_VERSION = "/version/v1";
+
+  @Autowired
+  private MockMvc mockMvc;
+  @MockBean
+  private LabServerService labServerService;
+  @MockBean
+  private TanService tanService;
+  @Autowired
+  private VerificationAppSessionRepository appSessionrepository;
+  @Autowired
+  private ObjectMapper mapper;
+
+  @BeforeEach
+  void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  /**
+   * Test generateTAN.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGenerateTAN() throws Exception {
+    log.info("VerificationAppTests callGenerateTAN()");
+
+    prepareAppSessionTestData();
+    doReturn(TEST_LAB_POSITIVE_RESULT).when(labServerService).result(any());
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
+      .andExpect(status().isCreated());
+
+    long count = appSessionrepository.count();
+    log.info("Got {} verification entries from db repository.", count);
+    assertEquals("Verification Failed: Amount of verfication entries is not 1 (Result=" + count + "). ", 1, count);
+
+    List<VerificationAppSession> verficationList = appSessionrepository.findAll();
+    assertNotNull(verficationList);
+    assertEquals(TEST_GUI_HASH, verficationList.get(0).getHashedGuid());
+    assertEquals(AppSessionSourceOfTrust.HASHED_GUID, verficationList.get(0).getSourceOfTrust());
+    assertEquals(TEST_REG_TOK_HASH, verficationList.get(0).getRegistrationTokenHash());
+
+  }
+
+  /**
+   * Test generateTAN with an unknown registration token.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGenerateTanByUnknownToken() throws Exception {
+    log.info("VerificationAppTests callGenerateTanByUnknownToken()");
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test generateTAN with an negative test result from the lab-server.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGenerateTanWithNegativeCovidResult() throws Exception {
+    log.info("VerificationAppTests callGenerateTanWithNegativeCovidResult()");
+    prepareAppSessionTestData();
+    doReturn(TEST_LAB_NEGATIVE_RESULT).when(labServerService).result(any());
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test generateTAN with an registration token connected to an appsession
+   * based on a tele Tan.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGenerateTanWithTeleTanAppSession() throws Exception {
+    log.info("VerificationAppTests callGenerateTanWithTeleTanAppSession()");
+    appSessionrepository.deleteAll();
+    VerificationAppSession appSessionTestData = getAppSessionTestData();
+    appSessionTestData.setSourceOfTrust(AppSessionSourceOfTrust.TELETAN);
+    appSessionrepository.save(appSessionTestData);
+    doReturn(TEST_LAB_NEGATIVE_RESULT).when(labServerService).result(any());
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
+      .andExpect(status().isCreated());
+  }
+
+  /**
+   * Test generateTAN with an unknown source of trust in the appsession.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGenerateTanWithUnknownSourceOfTrust() throws Exception {
+    log.info("VerificationAppTests callGenerateTanWithUnknownSourceOfTrust()");
+    appSessionrepository.deleteAll();
+    VerificationAppSession appSessionTestData = getAppSessionTestData();
+    appSessionTestData.setSourceOfTrust(AppSessionSourceOfTrust.HASHED_GUID);
+    appSessionrepository.save(appSessionTestData);
+    doReturn(TEST_LAB_NEGATIVE_RESULT).when(labServerService).result(any());
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test the generation of a tele Tan.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGenerateTeleTAN() throws Exception {
+    log.info("VerificationAppTests callGenerateTeleTAN()");
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/teletan"))
+      .andExpect(status().isCreated());
+  }
+
+  /**
+   * Test get registration token by a guid.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetRegistrationTokenByGuid() throws Exception {
+    log.info("VerificationAppTests callGetRegistrationTokenByGuid() ");
+    appSessionrepository.deleteAll();
+    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_GUI_HASH, RegistrationTokenKeyType.GUID);
+    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(request)))
+      .andExpect(status().isCreated())
+      .andExpect(jsonPath("$.token").exists());
+
+    long count = appSessionrepository.count();
+    log.info("Got {} verification entries from db repository.", count);
+    assertEquals("Verification Failed: Amount of verfication entries is not 1 (Result=" + count + "). ", 1, count);
+
+    List<VerificationAppSession> verificationList = appSessionrepository.findAll();
+    assertNotNull(verificationList);
+    assertEquals(TEST_GUI_HASH, verificationList.get(0).getHashedGuid());
+    assertEquals(AppSessionSourceOfTrust.HASHED_GUID, verificationList.get(0).getSourceOfTrust());
+    assertNotNull(verificationList.get(0).getRegistrationTokenHash());
+  }
+
+  /**
+   * Test get registration token by a tele tan.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetRegistrationTokenByTeleTan() throws Exception {
+    log.info("VerificationAppTests callGetRegistrationTokenByTeleTan() ");
+    appSessionrepository.deleteAll();
+    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_TELE_TAN, RegistrationTokenKeyType.TELETAN);
+    given(this.tanService.verifyTeleTan(TEST_TELE_TAN)).willReturn(true);
+    given(this.tanService.isTeleTanValid(TEST_TELE_TAN)).willReturn(true);
+    given(this.tanService.getEntityByTan(TEST_TELE_TAN)).willReturn(Optional.of(getTeleTanTestData()));
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(request)))
+      .andExpect(status().isCreated())
+      .andExpect(jsonPath("$.token").exists());
+
+    long count = appSessionrepository.count();
+    log.info("Got {} verification entries from db repository.", count);
+    assertEquals("Verification Failed: Amount of verfication entries is not 1 (Result=" + count + "). ", 1, count);
+
+    List<VerificationAppSession> verificationList = appSessionrepository.findAll();
+    assertNotNull(verificationList);
+    assertNull(verificationList.get(0).getHashedGuid());
+    assertEquals(AppSessionSourceOfTrust.TELETAN, verificationList.get(0).getSourceOfTrust());
+    assertNotNull(verificationList.get(0).getRegistrationTokenHash());
+  }
+
+  /**
+   * Test get registration token by a unknown Tele-Tan.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetRegistrationTokenByUnknownTeleTan() throws Exception {
+    log.info("VerificationAppTests callGetRegistrationTokenByUnknownTeleTan() ");
+    appSessionrepository.deleteAll();
+    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_TELE_TAN, RegistrationTokenKeyType.TELETAN);
+    given(this.tanService.verifyTeleTan(TEST_TELE_TAN)).willReturn(true);
+    given(this.tanService.getEntityByTan(TEST_TELE_TAN)).willReturn(Optional.empty());
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(request)))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test get registration token by a unknown Tele-Tan.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetRegistrationTokenByInvalidHashedGUID() throws Exception {
+    log.info("VerificationAppTests callGetRegistrationTokenByInvalidHashedGUID() ");
+    appSessionrepository.deleteAll();
+    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_INVALID_GUI_HASH, RegistrationTokenKeyType.GUID);
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(request)))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test get registration token for a guid, but the guid already has a
+   * registration token.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetRegistrationTokenByAlreadyExistForGUID() throws Exception {
+    log.info("VerificationAppTests callGetRegistrationTokenByInvalidHashedGUID() ");
+    prepareAppSessionTestData();
+    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_GUI_HASH, RegistrationTokenKeyType.GUID);
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(request)))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test get registration token for a teletan, but the teletan already has a
+   * registration token.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetRegistrationTokenByAlreadyExistForTeleTan() throws Exception {
+    log.info("VerificationAppTests callGetRegistrationTokenByInvalidHashedGUID() ");
+
+    appSessionrepository.deleteAll();
+    VerificationAppSession appSessionTestData = getAppSessionTestData();
+    appSessionTestData.setTeleTanHash(TEST_TELE_TAN_HASH);
+    appSessionrepository.save(appSessionTestData);
+
+    given(this.tanService.verifyTeleTan(TEST_TELE_TAN)).willReturn(true);
+
+    RegistrationTokenRequest request = new RegistrationTokenRequest(TEST_TELE_TAN, RegistrationTokenKeyType.TELETAN);
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/registrationToken")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(request)))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test getTestState.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetTestState() throws Exception {
+    log.info("VerificationAppTests callGetTestState()");
+
+    prepareAppSessionTestData();
+
+    given(this.labServerService.result(new HashedGuid(TEST_GUI_HASH))).willReturn(TEST_LAB_POSITIVE_RESULT);
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/testresult").contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
+      .andExpect(status().isOk())
+      .andExpect(jsonPath("$.testResult").value(TEST_LAB_POSITIVE_RESULT.getTestResult()));
+  }
+
+  /**
+   * Test getTestState with empty Entity of VerificationAppSession.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGetTestStateByAppSessionIsEmpty() throws Exception {
+    log.info("VerificationAppTests callGetTestStateByAppSessionIsEmpty()");
+
+    //clean the repo
+    appSessionrepository.deleteAll();
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/testresult")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
+      .andExpect(status().isBadRequest());
+  }
+
+  /**
+   * Test verifyTAN.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callVerifyTAN() throws Exception {
+    log.info("VerificationAppTests callVerifyTAN()");
+
+    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
+    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(getVerificationTANTestData()));
+
+    assertFalse("Is TAN redeemed?", this.tanService.getEntityByTan(TEST_TAN).get().isRedeemed());
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new Tan(TEST_TAN))))
+      .andExpect(status().isOk());
+  }
+
+  /**
+   * Test verifyTAN with empty Entity.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callVerifyTANByVerificationTANIsEmpty() throws Exception {
+    log.info("VerificationAppTests callVerifyTANByVerificationTANIsEmpty()");
+
+    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
+    // without mock tanService.getEntityByTan so this method will return empty entity
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify")
+      .contentType(MediaType.APPLICATION_JSON)
+      .content(getAsJsonFormat(new Tan(TEST_TAN))))
+      .andExpect(status().isNotFound());
+  }
+
+  /**
+   * Test verifyTAN with syntax problems.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callVerifyTANByTanSyntaxFailed() throws Exception {
+    log.info("VerificationAppTests callVerifyTANByTanSyntaxFailed()");
+
+    // without mock tanService.syntaxVerification so this method will return false
+    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(getVerificationTANTestData()));
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
+      .andExpect(status().isNotFound());
+  }
+
+  /**
+   * Test verifyTAN expired from.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callVerifyTANByExpiredTimeFrom() throws Exception {
+    log.info("VerificationAppTests callVerifyTANByTanSyntaxFailed()");
+
+    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
+    VerificationTan cvtan = getVerificationTANTestData();
+    // setValidFrom later 2 days then now
+    cvtan.setValidFrom(LocalDateTime.now().plusDays(2));
+    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(cvtan));
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
+      .andExpect(status().isNotFound());
+  }
+
+  /**
+   * Test verifyTAN expired until.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callVerifyTANByExpiredTimeUntil() throws Exception {
+    log.info("VerificationAppTests callVerifyTANByTanSyntaxFailed()");
+
+    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
+    VerificationTan cvtan = getVerificationTANTestData();
+    // setValidUntil earlier 2 days then now
+    cvtan.setValidUntil(LocalDateTime.now().minusDays(2));
+    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(cvtan));
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
+      .andExpect(status().isNotFound());
+  }
+
+  /**
+   * Test verifyTAN is redeemed.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callVerifyTANByIsRedeemed() throws Exception {
+    log.info("VerificationAppTests callVerifyTANByIsRedeemed()");
+
+    given(this.tanService.syntaxVerification(TEST_TAN)).willReturn(true);
+    VerificationTan cvtan = getVerificationTANTestData();
+    // tan is redeemed
+    cvtan.setRedeemed(true);
+    given(this.tanService.getEntityByTan(TEST_TAN)).willReturn(Optional.of(cvtan));
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/verify").contentType(MediaType.APPLICATION_JSON).content(getAsJsonFormat(new Tan(TEST_TAN))))
+      .andExpect(status().isNotFound());
+  }
+
+  private void prepareAppSessionTestData() {
+    appSessionrepository.deleteAll();
+    appSessionrepository.save(getAppSessionTestData());
+  }
+
+  private VerificationAppSession getAppSessionTestData() {
+    VerificationAppSession cv = new VerificationAppSession();
+    cv.setHashedGuid(TEST_GUI_HASH);
+    cv.setCreatedAt(LocalDateTime.now());
+    cv.setUpdatedAt(LocalDateTime.now());
+    cv.setTanCounter(0);
+    cv.setSourceOfTrust(AppSessionSourceOfTrust.HASHED_GUID);
+    cv.setRegistrationTokenHash(TEST_REG_TOK_HASH);
+    return cv;
+  }
+
+  private VerificationTan getVerificationTANTestData() {
+    VerificationTan cvtan = new VerificationTan();
+    cvtan.setCreatedAt(LocalDateTime.now());
+    cvtan.setUpdatedAt(LocalDateTime.now());
+    cvtan.setRedeemed(false);
+    cvtan.setSourceOfTrust(TEST_SOT);
+    cvtan.setTanHash(TEST_HASHED_TAN);
+    cvtan.setType(TEST_TAN_TYPE);
+    cvtan.setValidFrom(LocalDateTime.now().minusDays(5));
+    cvtan.setValidUntil(TAN_VALID_UNTIL_IN_DAYS);
+    return cvtan;
+  }
+
+  private VerificationTan getTeleTanTestData() {
+    VerificationTan cvtan = new VerificationTan();
+    cvtan.setCreatedAt(LocalDateTime.now());
+    cvtan.setUpdatedAt(LocalDateTime.now());
+    cvtan.setRedeemed(false);
+    cvtan.setSourceOfTrust(TanSourceOfTrust.TELETAN);
+    cvtan.setTanHash(TEST_HASHED_TAN);
+    cvtan.setType(TanType.TELETAN.name());
+    cvtan.setValidFrom(LocalDateTime.now());
+    cvtan.setValidUntil(LocalDateTime.now().plusHours(1));
+    return cvtan;
+  }
+
+  private String getAsJsonFormat(Object o) throws JsonProcessingException {
+    return mapper.writeValueAsString(o);
+  }
+}
diff --git a/src/test/java/app/coronawarn/verification/service/LabServerServiceTest.java b/src/test/java/app/coronawarn/verification/service/LabServerServiceTest.java
new file mode 100644
index 00000000..65f1bfa4
--- /dev/null
+++ b/src/test/java/app/coronawarn/verification/service/LabServerServiceTest.java
@@ -0,0 +1,68 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.service;
+
+import app.coronawarn.verification.VerificationApplication;
+import app.coronawarn.verification.client.HashedGuid;
+import app.coronawarn.verification.client.LabServerClient;
+import app.coronawarn.verification.client.TestResult;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringRunner;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+@RunWith(SpringRunner.class)
+@SpringBootTest
+@ContextConfiguration(classes = VerificationApplication.class)
+public class LabServerServiceTest {
+
+  public static final String TEST_GUI_HASH = "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b";
+  public static final TestResult TEST_LAB_POSITIVE_RESULT = new TestResult(2);
+  private LabServerService labServerService;
+
+  @Before
+  public void setUp() {
+    labServerService = new LabServerService(new LabServerClientMock());
+  }
+
+  /**
+   * Test result method.
+   */
+  @Test
+  public void resultTest() {
+    HashedGuid hashedGuid = new HashedGuid(TEST_GUI_HASH);
+    TestResult testResult = labServerService.result(hashedGuid);
+    assertThat(testResult).isEqualTo(TEST_LAB_POSITIVE_RESULT);
+  }
+
+  public static class LabServerClientMock implements LabServerClient {
+
+    @Override
+    public TestResult result(HashedGuid guid) {
+      return new TestResult(2);
+    }
+  }
+}
diff --git a/src/test/java/app/coronawarn/verification/service/TanServiceTest.java b/src/test/java/app/coronawarn/verification/service/TanServiceTest.java
index 723283f6..ae5bed71 100644
--- a/src/test/java/app/coronawarn/verification/service/TanServiceTest.java
+++ b/src/test/java/app/coronawarn/verification/service/TanServiceTest.java
@@ -23,15 +23,17 @@
 
 import app.coronawarn.verification.VerificationApplication;
 import app.coronawarn.verification.domain.VerificationTan;
+import app.coronawarn.verification.model.TanSourceOfTrust;
+import app.coronawarn.verification.model.TanType;
+import app.coronawarn.verification.repository.VerificationTanRepository;
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
 import java.util.Optional;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import lombok.extern.slf4j.Slf4j;
 import org.junit.Assert;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -39,29 +41,69 @@
 import org.springframework.test.context.ContextConfiguration;
 import org.springframework.test.context.junit4.SpringRunner;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@Slf4j
 @RunWith(SpringRunner.class)
 @SpringBootTest
 @ContextConfiguration(classes = VerificationApplication.class)
 public class TanServiceTest {
+
   public static final String TEST_TAN = "1ea6ce8a-9740-11ea-bb37-0242ac130002";
   public static final String TEST_TAN_HASH = "8de76b627f0be70ea73c367a9a560d6a987eacec71f57ca3d86b2e4ed5b6f780";
   public static final String TEST_GUI_HASH = "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b";
-  public static final String TEST_TAN_TYPE = "TAN";
+  public static final String TEST_TAN_TYPE = TanType.TAN.name();
+  public static final String TEST_TELE_TAN = "R3ZNUeV";
+  public static final String TEST_TELE_TAN_HASH = "eeaa54dc40aa84f587e3bc0cbbf18f7c05891558a5fe1348d52f3277794d8730";
   private static final String TELETAN_PATTERN = "^[2-9A-HJ-KMNP-Za-kmnp-z]{7}$";
-  private static final Pattern pattern = Pattern.compile(TELETAN_PATTERN);
-  private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ss.SSSSSS");
+  private static final TanSourceOfTrust TEST_TELE_TAN_SOURCE_OF_TRUST = TanSourceOfTrust.TELETAN;
+  private static final Pattern PATTERN = Pattern.compile(TELETAN_PATTERN);
+  private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ss.SSSSSS");
   private static final LocalDateTime TAN_VALID_UNTIL_IN_DAYS = LocalDateTime.now().plusDays(7);
 
   @Autowired
-  TanService tanService;
+  private TanService tanService;
+
+  @Autowired
+  private VerificationTanRepository tanRepository;
+
+  @Before
+  public void setUp() {
+    tanRepository.deleteAll();
+  }
+
+  /**
+   * Test delete Tan.
+   */
+  @Test
+  public void deleteTan() {
+    VerificationTan tan = new VerificationTan();
+    LocalDateTime start = LocalDateTime.parse(LocalDateTime.now().format(FORMATTER));
+    tan.setCreatedAt(start);
+    tan.setUpdatedAt(start);
+    tan.setRedeemed(false);
+    tan.setTanHash(TEST_TAN_HASH);
+
+    tan.setValidFrom(start);
+    tan.setValidUntil(LocalDateTime.parse((TAN_VALID_UNTIL_IN_DAYS.format(FORMATTER))));
+    tan.setType(TEST_TAN_TYPE);
+    tan.setSourceOfTrust(TEST_TELE_TAN_SOURCE_OF_TRUST);
+    tanService.saveTan(tan);
+
+    Optional<VerificationTan> tanFromDB = tanService.getEntityByTan(TEST_TAN);
+    Assert.assertEquals(tan, tanFromDB.get());
+    tanService.deleteTan(tan);
+    tanFromDB = tanService.getEntityByTan(TEST_TAN);
+    assertFalse(tanFromDB.isPresent());
+  }
 
   /**
    * Test saveTan.
-   *
-   * @throws Exception if the test cannot be performed.
    */
   @Test
-  public void saveTanTest() throws Exception {
+  public void saveTanTest() {
     VerificationTan tan = new VerificationTan();
     tan.setCreatedAt(LocalDateTime.now());
     tan.setUpdatedAt(LocalDateTime.now());
@@ -70,7 +112,7 @@ public void saveTanTest() throws Exception {
     tan.setValidFrom(LocalDateTime.now());
     tan.setValidUntil(TAN_VALID_UNTIL_IN_DAYS);
     tan.setType(TEST_TAN_TYPE);
-    tan.setSourceOfTrust("");
+    tan.setSourceOfTrust(TEST_TELE_TAN_SOURCE_OF_TRUST);
 
     VerificationTan retunedTan = tanService.saveTan(tan);
     Assert.assertEquals(retunedTan, tan);
@@ -79,30 +121,93 @@ public void saveTanTest() throws Exception {
   @Test
   public void getEntityByTanTest() {
     VerificationTan tan = new VerificationTan();
-    LocalDateTime start = LocalDateTime.parse(LocalDateTime.now().format(formatter));
+    LocalDateTime start = LocalDateTime.parse(LocalDateTime.now().format(FORMATTER));
     tan.setCreatedAt(start);
     tan.setUpdatedAt(start);
     tan.setRedeemed(false);
     tan.setTanHash(TEST_TAN_HASH);
-    
+
     tan.setValidFrom(start);
-    tan.setValidUntil(LocalDateTime.parse((TAN_VALID_UNTIL_IN_DAYS.format(formatter))));
+    tan.setValidUntil(LocalDateTime.parse((TAN_VALID_UNTIL_IN_DAYS.format(FORMATTER))));
     tan.setType(TEST_TAN_TYPE);
-    tan.setSourceOfTrust("");
+    tan.setSourceOfTrust(TEST_TELE_TAN_SOURCE_OF_TRUST);
     tanService.saveTan(tan);
 
     Optional<VerificationTan> tanFromDB = tanService.getEntityByTan(TEST_TAN);
-    assertTrue(tanFromDB.get().equals(tan));
+    Assert.assertEquals(tan, tanFromDB.get());
+  }
+
+  @Test
+  public void checkTanAlreadyExist() {
+    VerificationTan tan = new VerificationTan();
+    LocalDateTime start = LocalDateTime.parse(LocalDateTime.now().format(FORMATTER));
+    tan.setCreatedAt(start);
+    tan.setUpdatedAt(start);
+    tan.setRedeemed(false);
+    tan.setTanHash(TEST_TELE_TAN_HASH);
+
+    tan.setValidFrom(start);
+    tan.setValidUntil(LocalDateTime.parse((TAN_VALID_UNTIL_IN_DAYS.format(FORMATTER))));
+    tan.setType(TanType.TELETAN.name());
+    tan.setSourceOfTrust(TEST_TELE_TAN_SOURCE_OF_TRUST);
+    tanService.saveTan(tan);
+    assertFalse(tanService.checkTanNotExist(TEST_TELE_TAN));
+  }
+
+  @Test
+  public void generateVerificationTan() {
+    String tan = tanService.generateVerificationTan(TEST_TELE_TAN_SOURCE_OF_TRUST);
+    assertTrue(tanService.syntaxVerification(tan));
+    assertFalse(tan.isEmpty());
+  }
 
+  @Test
+  public void generateValidTan() {
+    String tan = tanService.generateValidTan();
+    assertTrue(tanService.syntaxVerification(tan));
+    assertFalse(tan.isEmpty());
   }
 
   @Test
   public void generateTeleTan() {
     String teleTan = tanService.generateTeleTan();
-    Matcher matcher = pattern.matcher(teleTan);
+    Matcher matcher = PATTERN.matcher(teleTan);
     assertTrue(matcher.find());
   }
 
+  @Test
+  public void verifyTeletan() {
+    String teleTan = tanService.generateVerificationTeleTan();
+    assertTrue(tanService.checkTanNotExist(TEST_TELE_TAN));
+    assertTrue(tanService.verifyTeleTan(teleTan));
+    assertFalse(tanService.verifyTeleTan("R3ZNUI0"));
+  }
+
+  @Test
+  public void verifyAlreadyRedeemedTeleTan() {
+    String teleTan = tanService.generateVerificationTeleTan();
+    VerificationTan teleTanFromDB = tanService.getEntityByTan(teleTan).get();
+    teleTanFromDB.setRedeemed(true);
+    tanService.saveTan(teleTanFromDB);
+    assertFalse(tanService.verifyTeleTan(teleTan));
+  }
+
+  @Test
+  public void verifyUnknownTeleTan() {
+    String teleTan = tanService.generateTeleTan();
+    assertFalse(tanService.verifyTeleTan(teleTan));
+  }
+
+  @Test
+  public void testTANFormat() {
+    assertThat(tanService.syntaxVerification("b430ce08-246d-4301-822c-c5d95f1edd13")).isTrue();
+    assertThat(tanService.syntaxVerification("ffc079f1-7060-4adb-93f8-6a6b95ad1124")).isTrue();
+    assertThat(tanService.syntaxVerification("ffc079f1")).isFalse();
+    assertThat(tanService.syntaxVerification("xfc079f1-7060-4adb-93f8-6a6b95ad1124")).isFalse();
+    assertThat(tanService.syntaxVerification("too-long-ffc079f1-7060-4adb-93f8-6a6b95ad1124")).isFalse();
+    assertThat(tanService.syntaxVerification("ffc079f1-7060-4adb-93f8-6a6b95ad1124-too-long")).isFalse();
+  }
+
   @Test
   public void testTeleTANFormat() {
     assertThat(tanService.isTeleTanValid("29zAE4E")).isTrue();
