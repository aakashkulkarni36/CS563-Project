diff --git a/.gitignore b/.gitignore
index 27620e94..af8dd026 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,34 +1,35 @@
-target/
-!.mvn/wrapper/maven-wrapper.jar
-!**/src/main/**
-!**/src/test/**
-
-### STS ###
-.apt_generated
-.classpath
-.factorypath
-.project
-.settings
-.springBeans
-.sts4-cache
-
-### IntelliJ IDEA ###
-.idea
-*.iws
-*.iml
-*.ipr
-
-### NetBeans ###
-/nbproject/private/
-/nbbuild/
-/dist/
-/nbdist/
-/.nb-gradle/
-build/
-nbactions.txt
-nbactions.xml
-
-### VS Code ###
-.vscode/
-
-/nb-configuration.xml
\ No newline at end of file
+target/
+!.mvn/wrapper/maven-wrapper.jar
+!**/src/main/**
+!**/src/test/**
+
+### STS ###
+.apt_generated
+.classpath
+.factorypath
+.project
+.settings
+.springBeans
+.sts4-cache
+
+### IntelliJ IDEA ###
+.idea
+*.iws
+*.iml
+*.ipr
+
+### NetBeans ###
+/nbproject/private/
+/nbbuild/
+/dist/
+/nbdist/
+/.nb-gradle/
+build/
+nbactions.txt
+nbactions.xml
+
+### VS Code ###
+.vscode/
+
+/nb-configuration.xml
+/nbproject/
diff --git a/THIRD-PARTY-NOTICES b/THIRD-PARTY-NOTICES
index 7b43d4ba..839a985d 100644
--- a/THIRD-PARTY-NOTICES
+++ b/THIRD-PARTY-NOTICES
@@ -56,8 +56,14 @@ Licensor:  springdoc-openapi
 Website:   https://springdoc.org/
 License:   Apache License 2.0
 
+Component: OpenFeign
+Licensor:  OpenFeign
+Website:   https://github.com/OpenFeign/feign
+License:   Apache License 2.0
+
 --------------------------------------------------------------------------------
-Apache License 2.0 (Apache Commons Codec, Maven, Spring Boot, Spring Doc)
+Apache License 2.0 (Apache Commons Codec, Maven,
+Spring Boot, Spring Doc, OpenFeign)
 
                                  Apache License
                            Version 2.0, January 2004
diff --git a/docs/architecture-overview.md b/docs/architecture-overview.md
index e77a6487..b02cd81d 100644
--- a/docs/architecture-overview.md
+++ b/docs/architecture-overview.md
@@ -80,26 +80,26 @@ Logfiles are kept for 30 days.
 
 Steps:
 1.	Scan the QR Code from the document provided by the test center/doctor
-[You can use numbers for reference-style link definitions][1] defined in User Story E07.01 – Scan QR Code with mobile App
+[You can use numbers for reference-style link definitions][1] defined in User Story E06.01 – Scan QR Code with mobile App
 1.	Create a long term Registration Token 
 - implemented in Use Case Create Registration Token
 3.	Generate Registration Token
 4.	Store Registration Token in mobile App
 5.	Polling for result, at a regular interval the mobile app uses the Registration Token to request the result of the test
-- defined in User Story E07.02 – Notify user if a test result is available
+- defined in User Story E06.02 – Notify user if a test result is available
 - partly implemented in Use Case Get Test Result
 6.	The Test Result Server is requested whether a result is available, for interface definition see [Test Result Server API]
 7.	The Test Result Server is returning the Test result, if no test is available a result with state “pending” is returned
 8.	The result is returned to the mobile App
 9.	The mobile app will request a TAN if a positive test result becomes available
-- defined in User Story E07.04 Upload my Diagnosis Keys
+- defined in User Story E06.04 Upload my Diagnosis Keys
 - implemented in Use Case Create TAN
 10.	A TAN is generated by the Verification Server and the TAN is stored hashed at the Verification Server
 11.	The TAN is delivered to the mobile App
 12.	The App obtains the Diagnosis Keys and sends them together with the TAN string to the Corona Warn App Backend
-- defined in User Story E07.04 Upload my Diagnosis Keys
+- defined in User Story E06.04 Upload my Diagnosis Keys
 13.	The Corona Warn App Backend verifies the upload request, by verifying the TAN at the Verification Server, to avoid false positive warnings and duplicate warnings.
-defined in User Story E06.01 – Avoid false positive reports
+defined in User Story E05.01 – Avoid false positive reports
 14.	The Verification Server verifies the TAN and returns the result of the verification
 - implemented in Use Case Verify TAN
 15.	The result is returned to the Corona-Warn-App Backend
@@ -207,7 +207,7 @@ API Endpoint:
 
 1.	Verify registrationToken, if registrationToken is invalid, exit with error HTTP 400
 2.	Verifiy whether the entity AppSession exists for the Registration token
-	1.	If yes, check if TANcounter >= 2
+	1.	If yes, check if TANcounter >= 1
 		1.	If yes, return error HTTP 400
 	1.	If no, return error HTTP 400
 3.	If AppSession.sourceOfTrust == “hashedGUID”
@@ -221,6 +221,7 @@ API Endpoint:
 6.	Update entity AppSession, increment TANcounter
 7.	Return TAN string
 
+
 ###	Use Case Create teleTAN
 API Endpoint:
 -	Method: POST /tan/teletan
@@ -293,15 +294,16 @@ The entity TAN represents the authorization (sometimes referred as “proof”)
 All data is deleted after 21 days.
 
 ##	Entity AppSession
-The entity AppSession is a hashed GUID which was used in processing to generate a TAN. The entity basically marks a GUID hash as “used”
+The entity AppSession is a hashed GUID which was used in processing to generate a TAN. The entity basically marks a GUID hash as “used”.
+
 |Name|	Not null|	Type|	Definition|
 | ------------- |:-------------:| -----:| -----:|
-|GUIDHash|	Y|	String[64]|	The hashed GUID.|
-|teleTANHash|	Y|	String[64]|	The hashed teleTAN.|
+|GUIDHash||	String[64]|	The hashed GUID.|
+|teleTANHash||	String[64]|	The hashed teleTAN.|
 |RegistrationTokenHash|	Y|	String[64]|	Hash of the Registration Token.|
 |TANcounter|	Y|Int|	Contains the number of TANs generated in the session|
 |sourceOfTrust|	Y|	String [“hashedGUID”, “teleTAN”]|Defines the type of the Session|
-|createdON|	Y|	Date	||
+|createdON|	Y|	Date	|Date of creation|
 
 ###	Data Deletion
 All data is deleted after 14 days.
diff --git a/pom.xml b/pom.xml
index 59ecc221..59295ff6 100644
--- a/pom.xml
+++ b/pom.xml
@@ -32,16 +32,18 @@
     <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
     <!-- dependencies -->
     <spring.boot.version>2.3.0.RELEASE</spring.boot.version>
+    <spring-security.version>5.2.3.RELEASE</spring-security.version>
     <spring.cloud.version>Hoxton.SR4</spring.cloud.version>
     <lombok.version>1.18.12</lombok.version>
     <liquibase.version>3.9.0</liquibase.version>
     <springdoc.version>1.3.9</springdoc.version>
+    <jsonwebtoken.version>0.9.1</jsonwebtoken.version>
+    <openfeign.version>11.0</openfeign.version>
     <!-- plugins -->
     <plugin.checkstyle.version>3.1.1</plugin.checkstyle.version>
     <plugin.sonar.version>3.6.1.1688</plugin.sonar.version>
     <plugin.jacoco.version>0.8.5</plugin.jacoco.version>
     <guava.version>29.0-jre</guava.version>
-    
     <sonar.coverage.exclusions>
       **/VerificationApplication.java,
       **/model/*,
@@ -127,6 +129,16 @@
         </exclusion>
       </exclusions>
     </dependency>
+    <dependency>
+      <groupId>io.github.openfeign</groupId>
+      <artifactId>feign-httpclient</artifactId>
+      <version>${openfeign.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.jsonwebtoken</groupId>
+      <artifactId>jjwt</artifactId>
+      <version>${jsonwebtoken.version}</version>
+    </dependency>
     <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-sleuth</artifactId>
@@ -176,6 +188,12 @@
       <artifactId>spring-boot-starter-test</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.springframework.security</groupId>
+      <artifactId>spring-security-core</artifactId>
+      <version>${spring-security.version}</version>
+      <type>jar</type>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/src/main/java/app/coronawarn/verification/VerificationApplication.java b/src/main/java/app/coronawarn/verification/VerificationApplication.java
index 05eadfb0..214835ff 100644
--- a/src/main/java/app/coronawarn/verification/VerificationApplication.java
+++ b/src/main/java/app/coronawarn/verification/VerificationApplication.java
@@ -41,6 +41,7 @@ public class VerificationApplication {
 
   /**
    * The main Method.
+   *
    * @param args the args for the main method
    */
   public static void main(String[] args) {
diff --git a/src/main/java/app/coronawarn/verification/client/IamClient.java b/src/main/java/app/coronawarn/verification/client/IamClient.java
new file mode 100644
index 00000000..9eea95f8
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/client/IamClient.java
@@ -0,0 +1,42 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.client;
+
+import app.coronawarn.verification.model.Certs;
+import org.springframework.cloud.openfeign.FeignClient;
+import org.springframework.http.MediaType;
+import org.springframework.web.bind.annotation.GetMapping;
+
+/**
+ * This class represents the IAM feign client.
+ */
+@FeignClient(name = "IamService", url = "${jwt.server}")
+public interface IamClient {
+  /**
+   * This method gets the cert information from the IAM Server.
+   * @return Testresult from server
+   */
+  @GetMapping(value = "/auth/realms/cwa/protocol/openid-connect/certs",
+    consumes = MediaType.APPLICATION_JSON_VALUE
+  )
+   Certs certs();
+}
diff --git a/src/main/java/app/coronawarn/verification/client/LabServerClient.java b/src/main/java/app/coronawarn/verification/client/TestResultServerClient.java
similarity index 84%
rename from src/main/java/app/coronawarn/verification/client/LabServerClient.java
rename to src/main/java/app/coronawarn/verification/client/TestResultServerClient.java
index 7b6dd2e4..badcd83f 100644
--- a/src/main/java/app/coronawarn/verification/client/LabServerClient.java
+++ b/src/main/java/app/coronawarn/verification/client/TestResultServerClient.java
@@ -30,12 +30,17 @@
 /**
  * This class represents the Labor Server service feign client.
  */
-@FeignClient(name = "labServerService", url = "${uri.endpoint.labserver}")
-public interface LabServerClient {
+@FeignClient(
+  name = "testResultServerClient",
+  url = "${cwa-testresult-server.url}",
+  configuration = TestResultServerClientConfig.class)
+public interface TestResultServerClient {
+
   /**
    * This method gets a testResult from the LabServer.
-   * @param guid for Testresult
-   * @return Testresult from server
+   *
+   * @param guid for TestResult
+   * @return TestResult from server
    */
   @PostMapping(value = "/api/v1/app/result",
     consumes = MediaType.APPLICATION_JSON_VALUE,
diff --git a/src/main/java/app/coronawarn/verification/client/TestResultServerClientConfig.java b/src/main/java/app/coronawarn/verification/client/TestResultServerClientConfig.java
new file mode 100644
index 00000000..1be405bd
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/client/TestResultServerClientConfig.java
@@ -0,0 +1,40 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.client;
+
+import feign.Client;
+import lombok.RequiredArgsConstructor;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+@Configuration
+@RequiredArgsConstructor
+public class TestResultServerClientConfig {
+
+  private final TestResultServerClientProvider testResultServerClientProvider;
+
+  @Bean
+  public Client feignClient() {
+    return testResultServerClientProvider.createFeignClient();
+  }
+
+}
diff --git a/src/main/java/app/coronawarn/verification/client/TestResultServerClientProvider.java b/src/main/java/app/coronawarn/verification/client/TestResultServerClientProvider.java
new file mode 100644
index 00000000..e236a621
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/client/TestResultServerClientProvider.java
@@ -0,0 +1,9 @@
+package app.coronawarn.verification.client;
+
+import feign.Client;
+
+public interface TestResultServerClientProvider {
+
+  Client createFeignClient();
+
+}
diff --git a/src/main/java/app/coronawarn/verification/client/TestResultServerClientProviderNoSsl.java b/src/main/java/app/coronawarn/verification/client/TestResultServerClientProviderNoSsl.java
new file mode 100644
index 00000000..faaced3e
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/client/TestResultServerClientProviderNoSsl.java
@@ -0,0 +1,53 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.client;
+
+import feign.Client;
+import feign.httpclient.ApacheHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.cloud.commons.httpclient.ApacheHttpClientConnectionManagerFactory;
+import org.springframework.cloud.commons.httpclient.ApacheHttpClientFactory;
+import org.springframework.cloud.commons.httpclient.DefaultApacheHttpClientConnectionManagerFactory;
+import org.springframework.cloud.commons.httpclient.DefaultApacheHttpClientFactory;
+import org.springframework.context.annotation.Bean;
+import org.springframework.stereotype.Component;
+
+@Component
+@ConditionalOnProperty(value = "cwa-testresult-server.ssl.enabled", havingValue = "false")
+public class TestResultServerClientProviderNoSsl implements TestResultServerClientProvider {
+
+  @Override
+  public Client createFeignClient() {
+    return new ApacheHttpClient();
+  }
+
+  @Bean
+  public ApacheHttpClientFactory createHttpClientFactory() {
+    return new DefaultApacheHttpClientFactory(HttpClientBuilder.create());
+  }
+
+  @Bean
+  public ApacheHttpClientConnectionManagerFactory createConnectionManager() {
+    return new DefaultApacheHttpClientConnectionManagerFactory();
+  }
+}
diff --git a/src/main/java/app/coronawarn/verification/client/TestResultServerClientProviderSsl.java b/src/main/java/app/coronawarn/verification/client/TestResultServerClientProviderSsl.java
new file mode 100644
index 00000000..16218ae9
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/client/TestResultServerClientProviderSsl.java
@@ -0,0 +1,70 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.client;
+
+import feign.Client;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import lombok.RequiredArgsConstructor;
+import org.apache.http.conn.ssl.NoopHostnameVerifier;
+import org.apache.http.ssl.SSLContextBuilder;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.stereotype.Component;
+import org.springframework.util.ResourceUtils;
+
+@Component
+@ConditionalOnProperty(value = "cwa-testresult-server.ssl.enabled", havingValue = "true")
+@RequiredArgsConstructor
+public class TestResultServerClientProviderSsl implements TestResultServerClientProvider {
+
+  @Value("${cwa-testresult-server.ssl.key-store}")
+  private String keyStorePath;
+  @Value("${cwa-testresult-server.ssl.key-store-password}")
+  private String keyStorePassword;
+  @Value("${cwa-testresult-server.ssl.trust-store}")
+  private String trustStorePath;
+  @Value("${cwa-testresult-server.ssl.trust-store-password}")
+  private String trustStorePassword;
+
+  @Override
+  public Client createFeignClient() {
+    return new Client.Default(getSslSocketFactory(), new NoopHostnameVerifier());
+  }
+
+  private SSLSocketFactory getSslSocketFactory() {
+    try {
+      SSLContext sslContext = SSLContextBuilder
+        .create()
+        .loadKeyMaterial(ResourceUtils.getFile(keyStorePath),
+          keyStorePassword.toCharArray(),
+          keyStorePassword.toCharArray())
+        .loadTrustMaterial(ResourceUtils.getFile(trustStorePath), trustStorePassword.toCharArray())
+        .build();
+      return sslContext.getSocketFactory();
+    } catch (IOException | GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/src/main/java/app/coronawarn/verification/config/SecurityConfig.java b/src/main/java/app/coronawarn/verification/config/SecurityConfig.java
index cf025c10..379cec23 100644
--- a/src/main/java/app/coronawarn/verification/config/SecurityConfig.java
+++ b/src/main/java/app/coronawarn/verification/config/SecurityConfig.java
@@ -38,7 +38,8 @@ protected HttpFirewall strictFirewall() {
     StrictHttpFirewall firewall = new StrictHttpFirewall();
     firewall.setAllowedHttpMethods(Arrays.asList(
       HttpMethod.GET.name(),
-      HttpMethod.POST.name()
+      HttpMethod.POST.name(),
+      HttpMethod.HEAD.name()
     ));
     return firewall;
   }
diff --git a/src/main/java/app/coronawarn/verification/config/VerificationApplicationConfig.java b/src/main/java/app/coronawarn/verification/config/VerificationApplicationConfig.java
index a14b40d7..020191f8 100644
--- a/src/main/java/app/coronawarn/verification/config/VerificationApplicationConfig.java
+++ b/src/main/java/app/coronawarn/verification/config/VerificationApplicationConfig.java
@@ -33,16 +33,25 @@
 @Setter
 @ConfigurationProperties
 public class VerificationApplicationConfig {
-
+  
   private TanCfg tan = new TanCfg();
   private AppSessionCfg appsession = new AppSessionCfg();
   private EntitiesCfg entities = new EntitiesCfg();
+  private JwtCfg jwt = new JwtCfg();
 
+  /**
+   * Configure the TeleCfg with build property values and return the configured
+   * parameters.
+   */
   public static class TeleCfg {
     @Getter
     @Setter
     private TeleValidCfg valid = new TeleValidCfg();
 
+    /**
+     * Configure the TeleValidCfg with build property values and return the
+     * configured parameters.
+     */
     public static class TeleValidCfg {
 
       // Number of hours that teleTAN remains valid
@@ -52,6 +61,10 @@ public static class TeleValidCfg {
     }
   }
 
+  /**
+   * Configure the ValidCfg with build property values and return the configured
+   * parameters.
+   */
   public static class ValidCfg {
 
     // Number of days that TAN remains valid
@@ -60,6 +73,10 @@ public static class ValidCfg {
     int days = 14;
   }
 
+  /**
+   * Configure the TanCfg with build property values and return the configured
+   * parameters.
+   */
   public static class TanCfg {
     @Getter
     @Setter
@@ -70,6 +87,10 @@ public static class TanCfg {
     private ValidCfg valid = new ValidCfg();
   }
 
+  /**
+   * Configure the AppSessionCfg with build property values and return the
+   * configured parameters.
+   */
   public static class AppSessionCfg {
 
     // Maximum number of tans in a session at one time
@@ -78,15 +99,33 @@ public static class AppSessionCfg {
     int tancountermax = 2;
   }
 
+  /**
+   * Configure the EntitiesCfg with build property values and return the
+   * configured parameters.
+   */
   public static class EntitiesCfg {
     @Getter
     @Setter
     private CleanupCfg cleanup = new CleanupCfg();
   }
 
+  /**
+   * Configure the CleanupCfg with build property values and return the
+   * configured parameters.
+   */
   public static class CleanupCfg {
     @Getter
     @Setter
     private Integer days = 21;
   }
+
+  /**
+   * Configure the JwtCfg with build property values and return the configured
+   * parameters.
+   */
+  public static class JwtCfg {
+    @Getter
+    @Setter
+    private String server;
+  }
 }
diff --git a/src/main/java/app/coronawarn/verification/controller/VerificationController.java b/src/main/java/app/coronawarn/verification/controller/VerificationController.java
index 210bd956..4ccf7acc 100644
--- a/src/main/java/app/coronawarn/verification/controller/VerificationController.java
+++ b/src/main/java/app/coronawarn/verification/controller/VerificationController.java
@@ -26,6 +26,7 @@
 import app.coronawarn.verification.domain.VerificationTan;
 import app.coronawarn.verification.exception.VerificationServerException;
 import app.coronawarn.verification.model.AppSessionSourceOfTrust;
+import app.coronawarn.verification.model.AuthorizationToken;
 import app.coronawarn.verification.model.HashedGuid;
 import app.coronawarn.verification.model.LabTestResult;
 import app.coronawarn.verification.model.RegistrationToken;
@@ -36,8 +37,9 @@
 import app.coronawarn.verification.model.TeleTan;
 import app.coronawarn.verification.model.TestResult;
 import app.coronawarn.verification.service.AppSessionService;
-import app.coronawarn.verification.service.LabServerService;
+import app.coronawarn.verification.service.JwtService;
 import app.coronawarn.verification.service.TanService;
+import app.coronawarn.verification.service.TestResultServerService;
 import io.swagger.v3.oas.annotations.Operation;
 import io.swagger.v3.oas.annotations.responses.ApiResponse;
 import io.swagger.v3.oas.annotations.responses.ApiResponses;
@@ -53,6 +55,7 @@
 import org.springframework.validation.annotation.Validated;
 import org.springframework.web.bind.annotation.PostMapping;
 import org.springframework.web.bind.annotation.RequestBody;
+import org.springframework.web.bind.annotation.RequestHeader;
 import org.springframework.web.bind.annotation.RequestMapping;
 import org.springframework.web.bind.annotation.RestController;
 
@@ -86,18 +89,25 @@ public class VerificationController {
    * The route to the teleTAN generation endpoint.
    */
   public static final String TELE_TAN_ROUTE = "/tan/teletan";
+  /**
+   * The http request header 'X-Auth-Token'.
+   */
+  private static final String REQ_HEADER_X_AUTH_TOKEN = "X-Auth-Token";
 
   @NonNull
   private final AppSessionService appSessionService;
 
   @NonNull
-  private final LabServerService labServerService;
+  private final TestResultServerService testResultServerService;
 
   @NonNull
   private final TanService tanService;
 
   @NonNull
-  private VerificationApplicationConfig verificationApplicationConfig;
+  private final VerificationApplicationConfig verificationApplicationConfig;
+
+  @NonNull
+  private final JwtService jwtService;
 
   /**
    * This method generates a registrationToken by a hashed guid or a teleTAN.
@@ -106,25 +116,25 @@ public class VerificationController {
    * @return RegistrationToken - the created registration token {@link RegistrationToken}
    */
   @Operation(
-      summary = "Get registration Token",
-      description = "Get a registration token by providing a SHA-256 hasehd GUID or a teleTAN"
+    summary = "Get registration Token",
+    description = "Get a registration token by providing a SHA-256 hasehd GUID or a teleTAN"
   )
   @ApiResponses(value = {
     @ApiResponse(responseCode = "201", description = "registration token generated."),
     @ApiResponse(responseCode = "400", description = "GUID/TeleTAN already exists.")})
   @PostMapping(value = REGISTRATION_TOKEN_ROUTE,
-      consumes = MediaType.APPLICATION_JSON_VALUE,
-      produces = MediaType.APPLICATION_JSON_VALUE
+    consumes = MediaType.APPLICATION_JSON_VALUE,
+    produces = MediaType.APPLICATION_JSON_VALUE
   )
   public ResponseEntity<RegistrationToken> generateRegistrationToken(
-      @Valid @RequestBody RegistrationTokenRequest request) {
+    @Valid @RequestBody RegistrationTokenRequest request) {
     String key = request.getKey();
     RegistrationTokenKeyType keyType = request.getKeyType();
     switch (keyType) {
       case GUID:
         if (appSessionService.verifyHashedGuid(key)) {
           return appSessionService.generateRegistrationToken(key, keyType);
-        } 
+        }
         throw new VerificationServerException(HttpStatus.BAD_REQUEST, "The hashed guid has no valid pattern");
       case TELETAN:
         if (tanService.verifyTeleTan(key)) {
@@ -136,10 +146,10 @@ public ResponseEntity<RegistrationToken> generateRegistrationToken(
             tanService.saveTan(teleTan);
             return response;
           }
-        } 
+        }
         throw new VerificationServerException(HttpStatus.BAD_REQUEST, "The teleTAN verification failed");
       default:
-        throw new VerificationServerException(HttpStatus.BAD_REQUEST, 
+        throw new VerificationServerException(HttpStatus.BAD_REQUEST,
           "Unknown registration key type for registration token");
     }
   }
@@ -152,20 +162,20 @@ public ResponseEntity<RegistrationToken> generateRegistrationToken(
    * @return A generated transaction number {@link Tan}.
    */
   @Operation(
-      summary = "Generates a Tan",
-      description = "Generates a TAN on input of Registration Token. With the TAN one can submit his Diagnosis keys"
+    summary = "Generates a Tan",
+    description = "Generates a TAN on input of Registration Token. With the TAN one can submit his Diagnosis keys"
   )
   @ApiResponses(value = {
     @ApiResponse(responseCode = "201", description = "Registration Token is valid"),
     @ApiResponse(responseCode = "400", description = "Registration Token does not exist")})
   @PostMapping(value = TAN_ROUTE,
-      consumes = MediaType.APPLICATION_JSON_VALUE,
-      produces = MediaType.APPLICATION_JSON_VALUE
+    consumes = MediaType.APPLICATION_JSON_VALUE,
+    produces = MediaType.APPLICATION_JSON_VALUE
   )
   public ResponseEntity<Tan> generateTan(@Valid @RequestBody RegistrationToken registrationToken) {
 
     Optional<VerificationAppSession> actual
-        = appSessionService.getAppSessionByToken(registrationToken.getRegistrationToken());
+      = appSessionService.getAppSessionByToken(registrationToken.getRegistrationToken());
     if (actual.isPresent()) {
       VerificationAppSession appSession = actual.get();
       int tancountermax = verificationApplicationConfig.getAppsession().getTancountermax();
@@ -174,9 +184,9 @@ public ResponseEntity<Tan> generateTan(@Valid @RequestBody RegistrationToken reg
         TanSourceOfTrust tanSourceOfTrust = TanSourceOfTrust.CONNECTED_LAB;
         switch (appSessionSourceOfTrust) {
           case HASHED_GUID:
-            TestResult covidTestResult = labServerService.result(new HashedGuid(appSession.getHashedGuid()));
+            TestResult covidTestResult = testResultServerService.result(new HashedGuid(appSession.getHashedGuid()));
             if (covidTestResult.getTestResult() != LabTestResult.POSITIVE.getTestResult()) {
-              throw new VerificationServerException(HttpStatus.BAD_REQUEST, 
+              throw new VerificationServerException(HttpStatus.BAD_REQUEST,
                 "Tan cannot be created, caused by the non positive result of the labserver");
             }
             break;
@@ -184,7 +194,7 @@ public ResponseEntity<Tan> generateTan(@Valid @RequestBody RegistrationToken reg
             tanSourceOfTrust = TanSourceOfTrust.TELETAN;
             break;
           default:
-            throw new VerificationServerException(HttpStatus.BAD_REQUEST, 
+            throw new VerificationServerException(HttpStatus.BAD_REQUEST,
               "Unknown source of trust inside the appsession for the registration token");
         }
         String generatedTan = tanService.generateVerificationTan(tanSourceOfTrust);
@@ -195,8 +205,8 @@ public ResponseEntity<Tan> generateTan(@Valid @RequestBody RegistrationToken reg
       throw new VerificationServerException(HttpStatus.BAD_REQUEST,
         "The maximum of generating tans for this registration token is reached");
     }
-    throw new VerificationServerException(HttpStatus.BAD_REQUEST, 
-        "VerificationAppSession not found for the registration token");
+    throw new VerificationServerException(HttpStatus.BAD_REQUEST,
+      "VerificationAppSession not found for the registration token");
   }
 
   /**
@@ -204,7 +214,7 @@ public ResponseEntity<Tan> generateTan(@Valid @RequestBody RegistrationToken reg
    *
    * @param registrationToken generated by a hashed guid {@link RegistrationToken}
    * @return the test result / status of the COVID-19 test, which can be POSITIVE, NEGATIVE, INVALID, PENDING or FAILED
-   *         and will always be POSITIVE for a TeleTan
+   *     and will always be POSITIVE for a TeleTan
    */
   @Operation(
     summary = "COVID-19 test result for given RegistrationToken",
@@ -214,8 +224,8 @@ public ResponseEntity<Tan> generateTan(@Valid @RequestBody RegistrationToken reg
   @ApiResponses(value = {
     @ApiResponse(responseCode = "200", description = "Testresult retrieved")})
   @PostMapping(value = TESTRESULT_ROUTE,
-      consumes = MediaType.APPLICATION_JSON_VALUE,
-      produces = MediaType.APPLICATION_JSON_VALUE
+    consumes = MediaType.APPLICATION_JSON_VALUE,
+    produces = MediaType.APPLICATION_JSON_VALUE
   )
 
   public ResponseEntity<TestResult> getTestState(@Valid @RequestBody RegistrationToken registrationToken) {
@@ -227,11 +237,11 @@ public ResponseEntity<TestResult> getTestState(@Valid @RequestBody RegistrationT
       }
       String hash = appSession.get().getHashedGuid();
       log.info("Requested result for registration token with hashed Guid.");
-      TestResult testResult = labServerService.result(new HashedGuid(hash));
+      TestResult testResult = testResultServerService.result(new HashedGuid(hash));
       return ResponseEntity.ok(testResult);
     }
     log.info("The registration token doesn't exists.");
-    throw new VerificationServerException(HttpStatus.BAD_REQUEST, 
+    throw new VerificationServerException(HttpStatus.BAD_REQUEST,
       "Returning the test result for the registration token failed");
   }
 
@@ -242,46 +252,52 @@ public ResponseEntity<TestResult> getTestState(@Valid @RequestBody RegistrationT
    * @return HTTP 200, if the verification was successful. Otherwise HTTP 404.
    */
   @Operation(
-      summary = "Verify provided Tan",
-      description = "The provided Tan is verified to be formerly issued by the verification server"
+    summary = "Verify provided Tan",
+    description = "The provided Tan is verified to be formerly issued by the verification server"
   )
   @ApiResponses(value = {
     @ApiResponse(responseCode = "200", description = "Tan is valid an formerly issued by the verification server"),
     @ApiResponse(responseCode = "404", description = "Tan could not be verified")})
   @PostMapping(value = TAN_VERIFY_ROUTE,
-      consumes = MediaType.APPLICATION_JSON_VALUE
+    consumes = MediaType.APPLICATION_JSON_VALUE
   )
   public ResponseEntity<?> verifyTan(@Valid @RequestBody Tan tan) {
     return tanService.getEntityByTan(tan.getTan())
-        .filter(t -> t.canBeRedeemed(LocalDateTime.now()))
-        .map(t -> {
-          tanService.deleteTan(t);
-          return t;
-        })
-        .map(t -> ResponseEntity.ok().build())
-        .orElseGet(() -> {
-          log.info("The Tan is invalid.");
-          throw new VerificationServerException(HttpStatus.NOT_FOUND, "No Tan found");
-        });
+      .filter(t -> t.canBeRedeemed(LocalDateTime.now()))
+      .map(t -> {
+        tanService.deleteTan(t);
+        return t;
+      })
+      .map(t -> ResponseEntity.ok().build())
+      .orElseGet(() -> {
+        log.info("The Tan is invalid.");
+        throw new VerificationServerException(HttpStatus.NOT_FOUND, "No Tan found");
+      });
   }
 
   /**
    * This method generates a valid teleTAN.
    *
-   * @return a created teleTAN
+   * @param authorization auth
+   * @return a created teletan
    */
   @Operation(
-      summary = "Request generation of a teleTAN",
-      description = "A teleTAN is a human readable TAN with 7 characters which is supposed to be issued via call line"
+    summary = "Request generation of a teleTAN",
+    description = "A teleTAN is a human readable TAN with 7 characters which is supposed to be issued via call line"
   )
   @ApiResponses(value = {
     @ApiResponse(responseCode = "201", description = "TeleTan created")})
   @PostMapping(value = TELE_TAN_ROUTE,
-      produces = MediaType.APPLICATION_JSON_VALUE
+    produces = MediaType.APPLICATION_JSON_VALUE
   )
-  public ResponseEntity<TeleTan> createTeleTan() {
-    String teleTan = tanService.generateVerificationTeleTan();
-    log.info("The teleTAN is generated.");
-    return ResponseEntity.status(HttpStatus.CREATED).body(new TeleTan(teleTan));
+  public ResponseEntity<TeleTan> createTeleTan(
+    @RequestHeader(REQ_HEADER_X_AUTH_TOKEN) @Valid AuthorizationToken authorization) {
+    if (jwtService.isAuthorized(authorization.getToken())) {
+      String teleTan = tanService.generateVerificationTeleTan();
+      log.info("The teleTAN is generated.");
+      return ResponseEntity.status(HttpStatus.CREATED).body(new TeleTan(teleTan));
+    }
+    throw new VerificationServerException(HttpStatus.UNAUTHORIZED, "JWT is invalid.");
   }
+
 }
diff --git a/src/main/java/app/coronawarn/verification/controller/VerificationExceptionHandler.java b/src/main/java/app/coronawarn/verification/controller/VerificationExceptionHandler.java
index 80ee029d..a37b721d 100644
--- a/src/main/java/app/coronawarn/verification/controller/VerificationExceptionHandler.java
+++ b/src/main/java/app/coronawarn/verification/controller/VerificationExceptionHandler.java
@@ -43,6 +43,7 @@ public class VerificationExceptionHandler {
 
   /**
    * This method handles unknown Exceptions and Server Errors.
+   *
    * @param ex the thrown exception
    * @param wr the WebRequest
    */
@@ -54,6 +55,7 @@ public void unknownException(Exception ex, WebRequest wr) {
 
   /**
    * This method handles Bad Requests.
+   *
    * @param ex the thrown exception
    * @param wr the WebRequest
    */
@@ -68,6 +70,7 @@ public void bindingExceptions(Exception ex, WebRequest wr) {
 
   /**
    * This method handles Validation Exceptions.
+   *
    * @return ResponseEntity<?> returns Bad Request
    */
   @ExceptionHandler({
@@ -80,6 +83,7 @@ public ResponseEntity<?> handleValidationExceptions() {
 
   /**
    * This method handles Validation Exceptions.
+   *
    * @param exception the thrown exception
    * @return ResponseEntity<?> returns a HTTP Status
    */
diff --git a/src/main/java/app/coronawarn/verification/exception/VerificationServerException.java b/src/main/java/app/coronawarn/verification/exception/VerificationServerException.java
index 4611ffb3..dad4fc12 100644
--- a/src/main/java/app/coronawarn/verification/exception/VerificationServerException.java
+++ b/src/main/java/app/coronawarn/verification/exception/VerificationServerException.java
@@ -4,9 +4,9 @@
  * (C) 2020, T-Systems International GmbH
  *
  * Deutsche Telekom AG, SAP AG and all other contributors /
- * copyright owners license this file to you under the Apache 
- * License, Version 2.0 (the "License"); you may not use this 
- * file except in compliance with the License. 
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
@@ -34,8 +34,9 @@ public class VerificationServerException extends RuntimeException {
 
   /**
    * The Constructor for the Exception class.
+   *
    * @param httpStatus the state of the server
-   * @param message the message
+   * @param message    the message
    */
   public VerificationServerException(HttpStatus httpStatus, String message) {
     super(message);
diff --git a/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java b/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java
index 1ba4114c..817f37ae 100644
--- a/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java
+++ b/src/main/java/app/coronawarn/verification/model/AppSessionSourceOfTrust.java
@@ -23,6 +23,7 @@
 
 /**
  * This class represents the possible sources of trust for an appsession entity.
+ *
  * @see <a href="https://github.com/corona-warn-app/cwa-verification-server/blob/master/docs/architecture-overview.md#entity-appsession">Entity AppSession - sourceOfTrust</a>
  */
 public enum AppSessionSourceOfTrust {
diff --git a/src/main/java/app/coronawarn/verification/model/AuthorizationRole.java b/src/main/java/app/coronawarn/verification/model/AuthorizationRole.java
new file mode 100644
index 00000000..244107ce
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/model/AuthorizationRole.java
@@ -0,0 +1,43 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG, SAP AG and all other contributors /
+ * copyright owners license this file to you under the Apache 
+ * License, Version 2.0 (the "License"); you may not use this 
+ * file except in compliance with the License. 
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.model;
+
+import lombok.Getter;
+
+/**
+ * The differrent possible roles, which are authorizated to create a tele tan.
+ *
+ * @see
+ * <a href="https://github.com/corona-warn-app/cwa-verification-server/blob/master/docs/architecture-overview.md#use-case-create-teletan">
+ * Use Case - Create TeleTan</a>
+ */
+@Getter
+public enum AuthorizationRole {
+  AUTH_C19_HOTLINE("c19hotline"),
+  AUTH_C19_HEALTHAUTHORITY("c19healthauthority");
+
+  private final String roleName;
+
+  private AuthorizationRole(final String role) {
+    this.roleName = role;
+  }
+}
diff --git a/src/main/java/app/coronawarn/verification/model/AuthorizationToken.java b/src/main/java/app/coronawarn/verification/model/AuthorizationToken.java
new file mode 100644
index 00000000..caac88da
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/model/AuthorizationToken.java
@@ -0,0 +1,44 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG, SAP AG and all other contributors /
+ * copyright owners license this file to you under the Apache 
+ * License, Version 2.0 (the "License"); you may not use this 
+ * file except in compliance with the License. 
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.model;
+
+import io.swagger.v3.oas.annotations.media.Schema;
+import javax.validation.constraints.NotNull;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+/**
+ * This class represents the authorization token (JWT), which is used for the
+ * creation of a teleTan.
+ */
+@Schema(
+  description = "The jwt token header model."
+)
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+public class AuthorizationToken {
+
+  @NotNull
+  private String token;
+}
diff --git a/src/main/java/app/coronawarn/verification/model/Certs.java b/src/main/java/app/coronawarn/verification/model/Certs.java
new file mode 100644
index 00000000..6ecbca19
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/model/Certs.java
@@ -0,0 +1,38 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.model;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+public class Certs {
+  
+  private List<Key> keys = null;
+  private Map<String, Object> additionalProperties = new HashMap<>();
+}
diff --git a/src/main/java/app/coronawarn/verification/model/HashedGuid.java b/src/main/java/app/coronawarn/verification/model/HashedGuid.java
index 558c632f..55f489ea 100644
--- a/src/main/java/app/coronawarn/verification/model/HashedGuid.java
+++ b/src/main/java/app/coronawarn/verification/model/HashedGuid.java
@@ -27,8 +27,9 @@
 import lombok.NoArgsConstructor;
 
 /**
- * This class represents the hashed Guid. 
+ * This class represents the hashed Guid.
  * Hash (SHA256) aka QR-Code, GUID encoded as hex string.
+ *
  * @see <a href="https://github.com/corona-warn-app/cwa-testresult-server/blob/master/docs/architecture-overview.md#core-entities">Core Entities</a>
  */
 @Schema(
diff --git a/src/main/java/app/coronawarn/verification/model/Key.java b/src/main/java/app/coronawarn/verification/model/Key.java
new file mode 100644
index 00000000..d7cf7041
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/model/Key.java
@@ -0,0 +1,56 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.model;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+public class Key {
+  public static final String SIG = "sig";
+  public static final String RS256 = "RS256";
+  private String kid;
+  private String kty;
+  private String alg;
+  private String use;
+  private String nn;
+  private String ee;
+  private List<String> x5c = null;
+  private String x5t;
+  private String x5tS256;
+  private final Map<String, Object> additionalProperties = new HashMap<>();
+  
+  /**
+   * Check if the cert is valid for use.
+   * @return <code>true</code>, if the cert has the right use and alg keys, otherwise <code>false</code>
+   */  
+  
+  public boolean isCertValid() {
+    return getUse().equals(SIG) && getAlg().equals(RS256);
+  }
+}
diff --git a/src/main/java/app/coronawarn/verification/model/RegistrationToken.java b/src/main/java/app/coronawarn/verification/model/RegistrationToken.java
index 65189215..0ee7ab7e 100644
--- a/src/main/java/app/coronawarn/verification/model/RegistrationToken.java
+++ b/src/main/java/app/coronawarn/verification/model/RegistrationToken.java
@@ -32,13 +32,12 @@
  * This class represents the registration Token.
  */
 @Schema(
-  description = "The the registration token model."
+  description = "The registration token model."
 )
 @Data
 @NoArgsConstructor
 @AllArgsConstructor
 public class RegistrationToken {
-
   @NotNull
   @Pattern(regexp = "^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$")
   private String registrationToken;
diff --git a/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java b/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java
index 31cf2d90..989c08aa 100644
--- a/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java
+++ b/src/main/java/app/coronawarn/verification/model/RegistrationTokenRequest.java
@@ -31,7 +31,7 @@
  * This class represents a registration token request parameter with a hashed guid or a teleTAN.
  */
 @Schema(
-  description = "The the registration token request model."
+  description = "The registration token request model."
 )
 @Data
 @NoArgsConstructor
diff --git a/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java b/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java
index 5d1880b3..04ca6591 100644
--- a/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java
+++ b/src/main/java/app/coronawarn/verification/model/TanSourceOfTrust.java
@@ -23,6 +23,7 @@
 
 /**
  * This class represents the possible sources of trust for a TAN entity.
+ *
  * @see <a href="https://github.com/corona-warn-app/cwa-verification-server/blob/master/docs/architecture-overview.md#entity-tan">Entity TAN - sourceOfTrust</a>
  */
 public enum TanSourceOfTrust {
diff --git a/src/main/java/app/coronawarn/verification/model/TanType.java b/src/main/java/app/coronawarn/verification/model/TanType.java
index 9ae06cf6..2f009c09 100644
--- a/src/main/java/app/coronawarn/verification/model/TanType.java
+++ b/src/main/java/app/coronawarn/verification/model/TanType.java
@@ -25,6 +25,7 @@
 
 /**
  * This class represents the different types of tans.
+ *
  * @see <a href="https://github.com/corona-warn-app/cwa-verification-server/blob/master/docs/architecture-overview.md#entity-tan">Entity TAN - Type</a>
  */
 @Schema
diff --git a/src/main/java/app/coronawarn/verification/model/TestResult.java b/src/main/java/app/coronawarn/verification/model/TestResult.java
index 35bac5d1..e7cc3be7 100644
--- a/src/main/java/app/coronawarn/verification/model/TestResult.java
+++ b/src/main/java/app/coronawarn/verification/model/TestResult.java
@@ -28,6 +28,7 @@
 
 /**
  * This class represents the TestResult.
+ *
  * @see <a href="https://github.com/corona-warn-app/cwa-testresult-server/blob/master/docs/architecture-overview.md#core-entities">Core Entities</a>
  */
 @Schema(
diff --git a/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java b/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java
index cc7633e1..2b4245ba 100644
--- a/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java
+++ b/src/main/java/app/coronawarn/verification/repository/VerificationAppSessionRepository.java
@@ -33,13 +33,31 @@ public interface VerificationAppSessionRepository extends JpaRepository<Verifica
 
   /**
    * This method looks in the Database for an Appsession with the given registrationTokenHash.
+   *
    * @param registrationTokenHash hash to search for
    * @return Optional VerificationAppSession the optional Appsession
    */
   Optional<VerificationAppSession> findByRegistrationTokenHash(String registrationTokenHash);
 
+  /**
+   * This method looks in the Database for an Appsession with the given hashedGuid.
+   *
+   * @param hashedGuid hash to search for
+   * @return Optional VerificationAppSession the optional Appsession
+   */
+  Optional<VerificationAppSession> findByHashedGuid(String hashedGuid);
+  
+  /**
+   * This method looks in the Database for an Appsession with the given teleTanHash.
+   *
+   * @param teleTanHash hash to search for
+   * @return Optional VerificationAppSession the optional Appsession
+   */
+  Optional<VerificationAppSession> findByTeleTanHash(String teleTanHash);
+  
   /**
    * This method looks in the Database for Appsessions that are older than the before value and deletes them.
+   *
    * @param before the Date to delete by
    */
   void deleteByCreatedAtBefore(LocalDateTime before);
diff --git a/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java b/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java
index 9af72b5a..8854c3e3 100644
--- a/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java
+++ b/src/main/java/app/coronawarn/verification/repository/VerificationTanRepository.java
@@ -33,6 +33,7 @@ public interface VerificationTanRepository extends JpaRepository<VerificationTan
 
   /**
    * This method looks in the Database for an if a VerificationTan exists for the tan hash.
+   *
    * @param tanHash hash to search for
    * @return Boolean if there is an Entity for the tanHash
    */
@@ -40,6 +41,7 @@ public interface VerificationTanRepository extends JpaRepository<VerificationTan
 
   /**
    * This method looks in the Database for an if a VerificationTan exists for the tan hash.
+   *
    * @param tanHash hash to search for
    * @return Optional VerificationTan
    */
@@ -47,6 +49,7 @@ public interface VerificationTanRepository extends JpaRepository<VerificationTan
 
   /**
    * This method purges Entities from the database that are older than before value.
+   *
    * @param before LocalDateTime to delete older entities
    */
   void deleteByCreatedAtBefore(LocalDateTime before);
diff --git a/src/main/java/app/coronawarn/verification/service/AppSessionService.java b/src/main/java/app/coronawarn/verification/service/AppSessionService.java
index ed716274..c13d6cf3 100644
--- a/src/main/java/app/coronawarn/verification/service/AppSessionService.java
+++ b/src/main/java/app/coronawarn/verification/service/AppSessionService.java
@@ -32,8 +32,6 @@
 import lombok.NonNull;
 import lombok.RequiredArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
-import org.springframework.data.domain.Example;
-import org.springframework.data.domain.ExampleMatcher;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.ResponseEntity;
 import org.springframework.stereotype.Component;
@@ -158,9 +156,7 @@ public Optional<VerificationAppSession> getAppSessionByToken(String registration
    */
   public boolean checkRegistrationTokenAlreadyExistsForGuid(String hashedGuid) {
     log.info("Start checkRegistrationTokenAlreadyExistsForGuid.");
-    VerificationAppSession appSession = new VerificationAppSession();
-    appSession.setHashedGuid(hashedGuid);
-    return appSessionRepository.exists(Example.of(appSession, ExampleMatcher.matchingAll()));
+    return appSessionRepository.findByHashedGuid(hashedGuid).isPresent();
   }
 
   /**
@@ -172,13 +168,12 @@ public boolean checkRegistrationTokenAlreadyExistsForGuid(String hashedGuid) {
    */
   public boolean checkRegistrationTokenAlreadyExistForTeleTan(String teleTan) {
     log.info("Start checkTeleTanAlreadyExistForTeleTan.");
-    VerificationAppSession appSession = new VerificationAppSession();
-    appSession.setTeleTanHash(hashingService.hash(teleTan));
-    return appSessionRepository.exists(Example.of(appSession, ExampleMatcher.matchingAll()));
+    return appSessionRepository.findByTeleTanHash(hashingService.hash(teleTan)).isPresent();
   }
-  
+
   /**
    * Verifies the hashed guid.
+   *
    * @param hashedGuid the hashed Guid
    * @return flag for verification
    */
diff --git a/src/main/java/app/coronawarn/verification/service/JwtService.java b/src/main/java/app/coronawarn/verification/service/JwtService.java
new file mode 100644
index 00000000..5f355580
--- /dev/null
+++ b/src/main/java/app/coronawarn/verification/service/JwtService.java
@@ -0,0 +1,157 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package app.coronawarn.verification.service;
+
+import app.coronawarn.verification.client.IamClient;
+import app.coronawarn.verification.model.AuthorizationRole;
+import app.coronawarn.verification.model.Certs;
+import app.coronawarn.verification.model.Key;
+import io.jsonwebtoken.Claims;
+import io.jsonwebtoken.JwtException;
+import io.jsonwebtoken.Jwts;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class represents the JWT service for token authorization and validation.
+ */
+@Slf4j
+@RequiredArgsConstructor
+@Component
+public class JwtService {
+
+  /**
+   * The prefix for the json web token.
+   */
+  public static final String TOKEN_PREFIX = "Bearer ";
+  private static final String ROLES = "roles";
+  private static final String REALM_ACCESS = "realm_access";
+
+  @NonNull
+  private final IamClient iamClient;
+
+  /**
+   * Validates the given token is given, the token starts with the needed prefix, 
+   * the signing key is not null and the token is valid.
+   *
+   * @param authorizationToken The authorization token to validate
+   * @return <code>true</code>, if the token is valid, otherwise
+   * <code>false</code>
+   */
+  public boolean isAuthorized(String authorizationToken) {
+    if (null != authorizationToken && authorizationToken.startsWith(JwtService.TOKEN_PREFIX)) {
+      String jwtToken = authorizationToken.substring(JwtService.TOKEN_PREFIX.length());
+      return validateToken(jwtToken, getPublicKey());
+    }
+    return false;
+  }
+
+  /**
+   * Validates the given token. If one of the given roles
+   * {@link AuthorizationRole} exists and verified by a public key
+   *
+   * @param token The authorization token to validate
+   * @param publicKey the key from the IAM server
+   * @return <code>true</code>, if the token is valid, otherwise
+   * <code>false</code>
+   */
+  public boolean validateToken(final String token, final PublicKey publicKey) {
+    if (null != publicKey) {
+      try {
+        List<String> roleNames = getRoles(token, publicKey);
+        AuthorizationRole[] roles = AuthorizationRole.values();
+        for (AuthorizationRole role : roles) {
+          if (roleNames.contains(role.getRoleName())) {
+            return true;
+          }
+        }
+      } catch (JwtException ex) {
+        log.warn("Token is not valid: {}.", ex.getMessage());
+        return false;
+      }
+    }
+    log.warn("No public key for Token validation found.");
+    return false;
+  }
+
+  public String getSubject(final String token, final PublicKey publicKey) {
+    return getClaimFromToken(token, Claims::getSubject, publicKey);
+  }
+
+  private List<String> getRoles(final String token, final PublicKey publicKey) {
+    Map<String, List<String>> realm = getRealmFromToken(token, publicKey);
+    return realm.getOrDefault(ROLES, new ArrayList<>());
+  }
+
+  private Map<String, List<String>> getRealmFromToken(final String token, final PublicKey publicKey) {
+    final Claims claims = getAllClaimsFromToken(token, publicKey);
+    Map<String, List<String>> realms = claims.get(REALM_ACCESS, Map.class);
+    return realms;
+  }
+
+  public <T> T getClaimFromToken(final String token, Function<Claims, T> claimsResolver, final PublicKey publicKey) {
+    final Claims claims = getAllClaimsFromToken(token, publicKey);
+    return claimsResolver.apply(claims);
+  }
+
+  private Claims getAllClaimsFromToken(final String token, final PublicKey publicKey) {
+    Claims claims = Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token).getBody();
+    return claims;
+  }
+
+  /**
+   * Get the public key from IAM client.
+   *
+   * @return the calculated Public key from PEM
+   */
+  public PublicKey getPublicKey() {
+    Certs certs = iamClient.certs();
+    PublicKey pubKey = null;
+    for (Key key : certs.getKeys()) {
+      if (key.isCertValid()) {
+        String certb64 = key.getX5c().get(0);
+        try {
+          KeyFactory kf = KeyFactory.getInstance("RSA");
+          X509EncodedKeySpec keySpecX509 = new X509EncodedKeySpec(Base64.getMimeDecoder().decode(certb64));
+          return kf.generatePublic(keySpecX509);
+        } catch (NoSuchAlgorithmException | InvalidKeySpecException ex) {
+          log.warn("Error getting public key: {}.", ex.getMessage());
+        }
+      } else {
+        log.warn("Error getting public key - not the right use or alg key");
+      }
+    }
+    return pubKey;
+  }
+}
diff --git a/src/main/java/app/coronawarn/verification/service/TanService.java b/src/main/java/app/coronawarn/verification/service/TanService.java
index 24e05fc9..98099dcd 100644
--- a/src/main/java/app/coronawarn/verification/service/TanService.java
+++ b/src/main/java/app/coronawarn/verification/service/TanService.java
@@ -142,7 +142,7 @@ private String generateValidTan() {
   /**
    * This method generates a {@link VerificationTan} - entity and saves it.
    *
-   * @param tan the TAN
+   * @param tan     the TAN
    * @param tanType the TAN type
    * @return the persisted TAN
    */
diff --git a/src/main/java/app/coronawarn/verification/service/LabServerService.java b/src/main/java/app/coronawarn/verification/service/TestResultServerService.java
similarity index 85%
rename from src/main/java/app/coronawarn/verification/service/LabServerService.java
rename to src/main/java/app/coronawarn/verification/service/TestResultServerService.java
index dd8ce4ff..e8136d55 100644
--- a/src/main/java/app/coronawarn/verification/service/LabServerService.java
+++ b/src/main/java/app/coronawarn/verification/service/TestResultServerService.java
@@ -21,7 +21,7 @@
 
 package app.coronawarn.verification.service;
 
-import app.coronawarn.verification.client.LabServerClient;
+import app.coronawarn.verification.client.TestResultServerClient;
 import app.coronawarn.verification.model.HashedGuid;
 import app.coronawarn.verification.model.TestResult;
 import lombok.NonNull;
@@ -35,17 +35,18 @@
 @Slf4j
 @RequiredArgsConstructor
 @Component
-public class LabServerService {
+public class TestResultServerService {
 
   @NonNull
-  private final LabServerClient labServerClient;
+  private final TestResultServerClient testResultServerClient;
 
   /**
    * This method gives an TestResult for a guid.
+   *
    * @param guid hashed GUID
    * @return Testresult for GUID
    */
   public TestResult result(HashedGuid guid) {
-    return labServerClient.result(guid);
+    return testResultServerClient.result(guid);
   }
 }
diff --git a/src/main/resources/application.yml b/src/main/resources/application.yml
index 3d8be900..dc6743f7 100644
--- a/src/main/resources/application.yml
+++ b/src/main/resources/application.yml
@@ -19,6 +19,8 @@ feign:
         connect-timeout: 5000
         read-timeout: 5000
         logger-level: basic
+jwt:
+  server: http://localhost:8080
 springdoc:
   api-docs:
     path: /api/docs
@@ -58,11 +60,17 @@ tan:
   valid:
     days: 14
 appsession:
-  tancountermax: 2
-uri:
-  endpoint:
-    labserver: http://localhost:8088
+  tancountermax: 1
 entities:
   cleanup:
     days: 21
     rate: 3600000
+
+cwa-testresult-server:
+  url: http://localhost:8088
+  ssl:
+    enabled: false
+    key-store: none
+    key-store-password: none
+    trust-store: none
+    trust-store-password: none
diff --git a/src/test/java/app/coronawarn/verification/VerificationApplicationTest.java b/src/test/java/app/coronawarn/verification/VerificationApplicationTest.java
index 90aaaca5..fbe01e97 100644
--- a/src/test/java/app/coronawarn/verification/VerificationApplicationTest.java
+++ b/src/test/java/app/coronawarn/verification/VerificationApplicationTest.java
@@ -21,20 +21,51 @@
 
 package app.coronawarn.verification;
 
-import app.coronawarn.verification.model.HashedGuid;
-import app.coronawarn.verification.model.TestResult;
+import app.coronawarn.verification.config.VerificationApplicationConfig;
 import app.coronawarn.verification.domain.VerificationAppSession;
 import app.coronawarn.verification.domain.VerificationTan;
-import app.coronawarn.verification.model.*;
+import app.coronawarn.verification.model.AppSessionSourceOfTrust;
+import app.coronawarn.verification.model.AuthorizationRole;
+import app.coronawarn.verification.model.HashedGuid;
+import app.coronawarn.verification.model.RegistrationToken;
+import app.coronawarn.verification.model.RegistrationTokenKeyType;
+import app.coronawarn.verification.model.RegistrationTokenRequest;
+import app.coronawarn.verification.model.Tan;
+import app.coronawarn.verification.model.TanSourceOfTrust;
+import app.coronawarn.verification.model.TanType;
+import app.coronawarn.verification.model.TestResult;
 import app.coronawarn.verification.repository.VerificationAppSessionRepository;
-import app.coronawarn.verification.service.LabServerService;
+import app.coronawarn.verification.service.JwtService;
 import app.coronawarn.verification.service.TanService;
+import app.coronawarn.verification.service.TestResultServerService;
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import io.jsonwebtoken.Jwts;
+import io.jsonwebtoken.SignatureAlgorithm;
+import java.io.UnsupportedEncodingException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.PrivateKey;
+import java.time.Instant;
+import java.time.LocalDateTime;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 import lombok.extern.slf4j.Slf4j;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import org.junit.Test;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.runner.RunWith;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.when;
 import org.mockito.MockitoAnnotations;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
@@ -44,16 +75,6 @@
 import org.springframework.test.context.ContextConfiguration;
 import org.springframework.test.context.junit4.SpringRunner;
 import org.springframework.test.web.servlet.MockMvc;
-
-import java.time.LocalDateTime;
-import java.util.List;
-import java.util.Optional;
-
-import static org.junit.Assert.*;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.when;
 import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
 import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
 import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
@@ -88,13 +109,19 @@ public class VerificationApplicationTest {
   @Autowired
   private MockMvc mockMvc;
   @MockBean
-  private LabServerService labServerService;
+  private TestResultServerService testResultServerService;
   @MockBean
   private TanService tanService;
   @Autowired
   private VerificationAppSessionRepository appSessionrepository;
   @Autowired
   private ObjectMapper mapper;
+  
+  @Autowired
+  private VerificationApplicationConfig verificationApplicationConfig;
+
+  @MockBean
+  private JwtService jwtService;
 
   @BeforeEach
   void setUp() {
@@ -111,7 +138,7 @@ public void callGenerateTan() throws Exception {
     log.info("process callGenerateTan()");
 
     prepareAppSessionTestData();
-    doReturn(TEST_LAB_POSITIVE_RESULT).when(labServerService).result(any());
+    doReturn(TEST_LAB_POSITIVE_RESULT).when(testResultServerService).result(any());
 
     mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
       .contentType(MediaType.APPLICATION_JSON)
@@ -169,7 +196,7 @@ public void callGenerateTanByInvalidToken() throws Exception {
   public void callGenerateTanWithNegativeCovidResult() throws Exception {
     log.info("process callGenerateTanWithNegativeCovidResult()");
     prepareAppSessionTestData();
-    doReturn(TEST_LAB_NEGATIVE_RESULT).when(labServerService).result(any());
+    doReturn(TEST_LAB_NEGATIVE_RESULT).when(testResultServerService).result(any());
 
     mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
       .contentType(MediaType.APPLICATION_JSON)
@@ -187,7 +214,8 @@ public void callGenerateTanWithTanCounterMaximum() throws Exception {
     log.info("process callGenerateTanWithTanCounterMaximum()");
     appSessionrepository.deleteAll();
     VerificationAppSession appSessionTestData = getAppSessionTestData();
-    appSessionTestData.setTanCounter(2);
+    int tancountermax = verificationApplicationConfig.getAppsession().getTancountermax();
+    appSessionTestData.setTanCounter(tancountermax);
     appSessionrepository.save(appSessionTestData);
 
     mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
@@ -208,7 +236,7 @@ public void callGenerateTanWithTeleTanAppSession() throws Exception {
     VerificationAppSession appSessionTestData = getAppSessionTestData();
     appSessionTestData.setSourceOfTrust(AppSessionSourceOfTrust.TELETAN);
     appSessionrepository.save(appSessionTestData);
-    doReturn(TEST_LAB_NEGATIVE_RESULT).when(labServerService).result(any());
+    doReturn(TEST_LAB_NEGATIVE_RESULT).when(testResultServerService).result(any());
 
     mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
       .contentType(MediaType.APPLICATION_JSON)
@@ -228,7 +256,7 @@ public void callGenerateTanWithUnknownSourceOfTrust() throws Exception {
     VerificationAppSession appSessionTestData = getAppSessionTestData();
     appSessionTestData.setSourceOfTrust(AppSessionSourceOfTrust.HASHED_GUID);
     appSessionrepository.save(appSessionTestData);
-    doReturn(TEST_LAB_NEGATIVE_RESULT).when(labServerService).result(any());
+    doReturn(TEST_LAB_NEGATIVE_RESULT).when(testResultServerService).result(any());
 
     mockMvc.perform(post(PREFIX_API_VERSION + "/tan")
       .contentType(MediaType.APPLICATION_JSON)
@@ -245,10 +273,38 @@ public void callGenerateTanWithUnknownSourceOfTrust() throws Exception {
   public void callGenerateTeleTAN() throws Exception {
     log.info("process callGenerateTeleTAN()");
 
-    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/teletan"))
+    KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance("RSA");
+    keyGenerator.initialize(1024);
+    KeyPair kp = keyGenerator.genKeyPair();
+    String jwtString = getJwtTestData(3000, kp.getPrivate(), AuthorizationRole.AUTH_C19_HEALTHAUTHORITY);
+
+    when(this.jwtService.isAuthorized(any())).thenCallRealMethod();
+    given(this.jwtService.getPublicKey()).willReturn(kp.getPublic());
+    when(this.jwtService.validateToken(jwtString, kp.getPublic())).thenCallRealMethod();
+
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/teletan").header("X-Auth-Token", "Bearer " + jwtString))
       .andExpect(status().isCreated());
   }
 
+  /**
+   * Test the generation of a tele Tan, when the jwt is not authorized.
+   *
+   * @throws Exception if the test cannot be performed.
+   */
+  @Test
+  public void callGenerateTeleTanUnauthorized() throws Exception {
+    log.info("process callGenerateTeleTanUnauthorized()");
+
+    KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance("RSA");
+    keyGenerator.initialize(1024);
+    KeyPair kp = keyGenerator.genKeyPair();
+    given(this.jwtService.isAuthorized(any())).willReturn(false);
+    given(this.jwtService.getPublicKey()).willReturn(kp.getPublic());
+    String jwtString = getJwtTestData(3000, kp.getPrivate(), AuthorizationRole.AUTH_C19_HEALTHAUTHORITY);
+    mockMvc.perform(post(PREFIX_API_VERSION + "/tan/teletan").header("X-Auth-Token", "Bearer " + jwtString))
+      .andExpect(status().isUnauthorized());
+  }
+
   /**
    * Test get registration token by a guid.
    *
@@ -376,7 +432,6 @@ public void callGetRegistrationTokenByInvalidHashedGUID() throws Exception {
   }
 
   /**
-   *
    * Test get registration token for a guid, but the guid already has a registration token.
    *
    * @throws Exception if the test cannot be performed.
@@ -428,7 +483,7 @@ public void callGetTestState() throws Exception {
 
     prepareAppSessionTestData();
 
-    given(this.labServerService.result(new HashedGuid(TEST_GUI_HASH))).willReturn(TEST_LAB_POSITIVE_RESULT);
+    given(this.testResultServerService.result(new HashedGuid(TEST_GUI_HASH))).willReturn(TEST_LAB_POSITIVE_RESULT);
 
     mockMvc.perform(post(PREFIX_API_VERSION + "/testresult").contentType(MediaType.APPLICATION_JSON)
       .content(getAsJsonFormat(new RegistrationToken(TEST_REG_TOK))))
@@ -560,6 +615,38 @@ public void callVerifyTANByIsRedeemed() throws Exception {
       .andExpect(status().isNotFound());
   }
 
+  private String getJwtTestData(final long expirationSecondsToAdd, PrivateKey privateKey, AuthorizationRole... roles) throws UnsupportedEncodingException {
+    final Map<String, List<String>> realm_accessMap = new HashMap<>();
+    final List<String> roleNames = new ArrayList<>();
+    for (AuthorizationRole role : roles) {
+      roleNames.add(role.getRoleName());
+    }
+
+    realm_accessMap.put("roles", roleNames);
+
+    return Jwts.builder()
+      .setExpiration(Date.from(Instant.now().plusSeconds(expirationSecondsToAdd)))
+      .setIssuedAt(Date.from(Instant.now()))
+      .setId("baeaa733-521e-4d2e-8abe-95bb440a9f5f")
+      .setIssuer("http://localhost:8080/auth/realms/cwa")
+      .setAudience("account")
+      .setSubject("72b3b494-a0f4-49f5-b235-1e9f93c86e58")
+      .claim("auth_time", "1590742669")
+      .claim("iss", "http://localhost:8080/auth/realms/cwa")
+      .claim("aud", "account")
+      .claim("typ", "Bearer")
+      .claim("azp", "verification-portal")
+      .claim("session_state", "41cc4d83-e394-4d08-b887-28d8c5372d4a")
+      .claim("acr", "0")
+      .claim("realm_access", realm_accessMap)
+      .claim("resource_access", new HashMap())
+      .claim("scope", "openid profile email")
+      .claim("email_verified", false)
+      .claim("preferred_username", "test")
+      .signWith(SignatureAlgorithm.RS256, privateKey)
+      .compact();
+  }
+
   private void prepareAppSessionTestData() {
     appSessionrepository.deleteAll();
     appSessionrepository.save(getAppSessionTestData());
diff --git a/src/test/java/app/coronawarn/verification/service/EntitiesCleanupServiceTest.java b/src/test/java/app/coronawarn/verification/service/EntitiesCleanupServiceTest.java
index b54bf7f0..41cd11da 100644
--- a/src/test/java/app/coronawarn/verification/service/EntitiesCleanupServiceTest.java
+++ b/src/test/java/app/coronawarn/verification/service/EntitiesCleanupServiceTest.java
@@ -91,7 +91,7 @@ public void cleanupDatabaseTest() {
     Assert.assertEquals(testCreationTime.withNano(5), findTan.get().getCreatedAt().withNano(5));
     // wait
     Single.fromCallable(() -> true).delay(1, TimeUnit.SECONDS).toBlocking().value();
-    // find and check repos clean up
+    // find and check both repos clean up
     findSession = appSessionRepository.findByRegistrationTokenHash(TEST_REG_TOK_HASH);
     Assert.assertFalse(findSession.isPresent());
     findTan = tanRepository.findByTanHash(TEST_HASHED_TAN);
diff --git a/src/test/java/app/coronawarn/verification/service/JwtServiceTest.java b/src/test/java/app/coronawarn/verification/service/JwtServiceTest.java
new file mode 100644
index 00000000..7b6e60fb
--- /dev/null
+++ b/src/test/java/app/coronawarn/verification/service/JwtServiceTest.java
@@ -0,0 +1,208 @@
+/*
+ * Corona-Warn-App / cwa-verification
+ *
+ * (C) 2020, T-Systems International GmbH
+ *
+ * Deutsche Telekom AG and all other contributors /
+ * copyright owners license this file to you under the Apache
+ * License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package app.coronawarn.verification.service;
+
+import app.coronawarn.verification.VerificationApplication;
+import app.coronawarn.verification.client.IamClient;
+import app.coronawarn.verification.model.AuthorizationRole;
+import app.coronawarn.verification.model.Certs;
+import app.coronawarn.verification.model.Key;
+import io.jsonwebtoken.Jwts;
+import io.jsonwebtoken.SignatureAlgorithm;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.io.UnsupportedEncodingException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.time.Instant;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import lombok.Setter;
+import org.bouncycastle.util.io.pem.PemObject;
+import org.bouncycastle.util.io.pem.PemWriter;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringRunner;
+
+@RunWith(SpringRunner.class)
+@SpringBootTest
+@ContextConfiguration(classes = VerificationApplication.class)
+public class JwtServiceTest
+{
+  public static final String TOKEN_PREFIX = "Bearer ";
+  public static final String BEGIN_PEM = "-----BEGIN PUBLIC KEY-----";
+  public static final String END_PEM = "-----END PUBLIC KEY-----";
+  public static final String RSA = "RSA";
+  
+  private PublicKey publicKey;
+  private PrivateKey privateKey;
+
+  @Autowired
+  private JwtService jwtService;
+
+  @Before
+  public void setUp() throws NoSuchAlgorithmException {
+    KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(RSA);
+    keyGenerator.initialize(1024);
+    KeyPair kp = keyGenerator.genKeyPair();
+    publicKey = kp.getPublic();
+    privateKey = kp.getPrivate();
+  }
+
+  /**
+   * Test to validate an valid Token, with the
+   * {@link JwtService#validateToken(java.lang.String)} method.
+   *
+   * @throws java.io.UnsupportedEncodingException
+   * @throws java.security.NoSuchAlgorithmException
+   */
+  @Test
+  public void testValidateToken() throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    String jwToken = getJwtTestData(3000, AuthorizationRole.AUTH_C19_HOTLINE, AuthorizationRole.AUTH_C19_HEALTHAUTHORITY);
+    Assert.assertTrue(jwtService.validateToken(jwToken, publicKey));
+  }
+  
+  /**
+   * Test the negative case by not given public key, with the
+   * {@link JwtService#validateToken(java.lang.String)} method.
+   *
+   * @throws java.io.UnsupportedEncodingException
+   * @throws java.security.NoSuchAlgorithmException
+   */
+  @Test
+  public void testValidateTokenByPublicKeyIsNull() throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    String jwToken = getJwtTestData(3000, AuthorizationRole.AUTH_C19_HOTLINE, AuthorizationRole.AUTH_C19_HEALTHAUTHORITY);
+    Assert.assertFalse(jwtService.validateToken(jwToken, null));
+  }  
+
+  /**
+   * Test is Token authorized, with the
+   * {@link JwtService#isAuthorized(java.lang.String)} method.
+   *
+   * @throws java.io.UnsupportedEncodingException
+   * @throws java.security.NoSuchAlgorithmException
+   */
+  @Test
+  public void testAuthorizedToken() throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    String jwToken = getJwtTestData(3000, AuthorizationRole.AUTH_C19_HOTLINE, AuthorizationRole.AUTH_C19_HEALTHAUTHORITY);
+    IamClientMock clientMock = createIamClientMock();
+    jwtService = new JwtService(clientMock);
+    Assert.assertTrue(jwtService.isAuthorized(TOKEN_PREFIX + jwToken));
+  }
+
+  /**
+   * Test to validate an expired Token, with the
+   * {@link JwtService#validateToken(java.lang.String)} method.
+   *
+   * @throws java.io.UnsupportedEncodingException
+   * @throws java.security.NoSuchAlgorithmException
+   */
+  @Test
+  public void testExpiredToken() throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    String jwToken = getJwtTestData(0, AuthorizationRole.AUTH_C19_HOTLINE, AuthorizationRole.AUTH_C19_HEALTHAUTHORITY);
+    Assert.assertFalse(jwtService.validateToken(jwToken, publicKey));
+  }
+
+  private String getJwtTestData(final long expirationSecondsToAdd, AuthorizationRole... roles) throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    final Map<String, List<String>> realm_accessMap = new HashMap<>();
+    final List<String> roleNames = new ArrayList<>();
+    for (AuthorizationRole role : roles) {
+      roleNames.add(role.getRoleName());
+    }
+    realm_accessMap.put("roles", roleNames);
+    return Jwts.builder()
+            .setExpiration(Date.from(Instant.now().plusSeconds(expirationSecondsToAdd)))
+            .setIssuedAt(Date.from(Instant.now()))
+            .setId("baeaa733-521e-4d2e-8abe-95bb440a9f5f")
+            .setIssuer("http://localhost:8080/auth/realms/cwa")
+            .setAudience("account")
+            .setSubject("72b3b494-a0f4-49f5-b235-1e9f93c86e58")
+            .claim("auth_time", "1590742669")
+            .claim("iss", "http://localhost:8080/auth/realms/cwa")
+            .claim("aud", "account")
+            .claim("typ", "Bearer")
+            .claim("azp", "verification-portal")
+            .claim("session_state", "41cc4d83-e394-4d08-b887-28d8c5372d4a")
+            .claim("acr", "0")
+            .claim("realm_access", realm_accessMap)
+            .claim("resource_access", new HashMap<>())
+            .claim("scope", "openid profile email")
+            .claim("email_verified", false)
+            .claim("preferred_username", "test")
+            .signWith(SignatureAlgorithm.RS256, privateKey)
+            .compact();
+  }
+  
+  private IamClientMock createIamClientMock() {
+    StringWriter writer = new StringWriter();
+    PemWriter pemWriter = new PemWriter(writer);
+    try {
+      pemWriter.writeObject(new PemObject("PUBLIC KEY", publicKey.getEncoded()));
+      pemWriter.flush();
+      pemWriter.close();
+    } catch (IOException ex) {
+      Logger.getLogger(JwtServiceTest.class.getName()).log(Level.SEVERE, null, ex);
+    }
+    IamClientMock clientMock = new IamClientMock();
+    String pem = writer.toString().replaceAll(System.lineSeparator(), "").replace(BEGIN_PEM, "").replace(END_PEM, "");
+    clientMock.setPem(pem);
+    return clientMock;
+  }  
+
+  public static class IamClientMock implements IamClient
+  {
+    @Setter
+    String pem;
+
+    @Override
+    public Certs certs() {
+      Certs certs = new Certs();
+      List<Key> keys = new ArrayList<>();
+      Key key = new Key();
+      key.setKid("myqmD9sUqDTcCkprIixgYUh0dooxsCYL8HKSJ6fCMxc");
+      key.setKty("RSA");
+      key.setAlg("RS256");
+      key.setUse("sig");
+      key.setNn("v2PqGZrfX1TG19cKZWOTKWq3gBrHK4zT5dVEOS-a9vRk6Ab8XZiPIiX6K6d3w1srSpgol-UJ1gnNo9AoeCHOzwpOPBERfzcn4qKLkRE59dU_ZOfWUgWUN5awy_W5lYslBTCWj6_mEsLMgiAk2DWw9eqLsdmdNO_t-3HYs1Htn8do0Jb5cmuz0FOWSY-JrMxctG1EEbsjs9if3NdXL18s1yQK0UFkav2dfrOofdOu6fMInB0PzjjzJ7yCj-lwbZhnG1gHTfepRBvB-sV4U-uD-9lR3qUXX-VMDgLXO4-VlotWE0dwBhjrgzgkj92V2zCJx8V27UocnwBhQ0-377Zz3Q");
+      key.setEe("AQAB");
+      key.setX5t("s-pJCbOOR0JExZQ2Yh7-oeo_1tU");
+      key.setX5tS256("9fxRTYYStVwlh8Cvoxcx9CxK3D9559HcYBOU19_981M");
+      key.setX5c(Arrays.asList(pem));
+      keys.add(key);
+      certs.setKeys(keys);
+      return certs;
+    }
+  }
+}
diff --git a/src/test/java/app/coronawarn/verification/service/LabServerServiceTest.java b/src/test/java/app/coronawarn/verification/service/TestResultServerServiceTest.java
similarity index 81%
rename from src/test/java/app/coronawarn/verification/service/LabServerServiceTest.java
rename to src/test/java/app/coronawarn/verification/service/TestResultServerServiceTest.java
index 79122ce0..f91bfb3a 100644
--- a/src/test/java/app/coronawarn/verification/service/LabServerServiceTest.java
+++ b/src/test/java/app/coronawarn/verification/service/TestResultServerServiceTest.java
@@ -23,7 +23,7 @@
 
 import app.coronawarn.verification.VerificationApplication;
 import app.coronawarn.verification.model.HashedGuid;
-import app.coronawarn.verification.client.LabServerClient;
+import app.coronawarn.verification.client.TestResultServerClient;
 import app.coronawarn.verification.model.TestResult;
 import org.junit.Before;
 import org.junit.Test;
@@ -37,17 +37,17 @@
 @RunWith(SpringRunner.class)
 @SpringBootTest
 @ContextConfiguration(classes = VerificationApplication.class)
-public class LabServerServiceTest {
+public class TestResultServerServiceTest {
 
   public static final String TEST_GUI_HASH_1 = "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b";
   public static final String TEST_GUI_HASH_2 = "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13c";
   public static final TestResult TEST_LAB_POSITIVE_RESULT = new TestResult(2);
   public static final TestResult TEST_LAB_REDEEMED_RESULT = new TestResult(4);
-  private LabServerService labServerService;
+  private TestResultServerService testResultServerService;
 
   @Before
   public void setUp() {
-    labServerService = new LabServerService(new LabServerClientMock());
+    testResultServerService = new TestResultServerService(new TestResultServerClientMock());
   }
 
   /**
@@ -55,7 +55,7 @@ public void setUp() {
    */
   @Test
   public void resultPositiveTest() {
-    TestResult testResult = labServerService.result(new HashedGuid(TEST_GUI_HASH_1));
+    TestResult testResult = testResultServerService.result(new HashedGuid(TEST_GUI_HASH_1));
     assertThat(testResult).isEqualTo(TEST_LAB_POSITIVE_RESULT);
   }
   
@@ -64,11 +64,11 @@ public void resultPositiveTest() {
    */
   @Test
   public void resultRedeemedTest() {
-    TestResult testResult = labServerService.result(new HashedGuid(TEST_GUI_HASH_2));
+    TestResult testResult = testResultServerService.result(new HashedGuid(TEST_GUI_HASH_2));
     assertThat(testResult).isEqualTo(TEST_LAB_REDEEMED_RESULT);
   }  
 
-  public static class LabServerClientMock implements LabServerClient {
+  public static class TestResultServerClientMock implements TestResultServerClient {
     @Override
     public TestResult result(HashedGuid guid) {
       if(guid.getId().equals(TEST_GUI_HASH_1)){
